<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>呆尬猴的博客 </title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.59.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="呆尬猴的博客" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="呆尬猴的博客" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://chow1027.xyz/posts/" />

<meta property="og:updated_time" content="2019-12-03T18:45:06+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://chow1027.xyz" class="f3 fw2 hover-white no-underline white-90 dib">
      呆尬猴的博客
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      












    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/axios%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" class="link black dim">
        Axios使用手册
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      参考文献：
axios中文网
axios英文原文
GET 请求 /*为给定 ID 的 User 创建请求*/ axios.get('/user?ID = 12345') .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) /*可以通过对象传递 User 的 ID*/ axios.get('/user',{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); })  POST 请求 /*执行post请求*/ axios.post('user',{ firstName:'Fred', lastName:'Flintstone' }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); })  执行多个并发请求 function getUserAccount(){ return axios.get('/user/12345'); } function getUserPermissions(){ return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms){ // 两个请求现在都执行完成 }));  创建请求 /*发送POST请求*/ axios({ method:'post', url:'/user/12345', data:{ firstName:'Fred', lastName:'Flintstone' } }); /*获取远端照片*/ axios({ method:'get', url:'http://bit.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/jquery%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/" class="link black dim">
        JQuery中的函数
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      版权声明：本文为周啟尧原创文章，著作权归本人和饥人谷所有，转载务必注明来源
&mdash;参考资料来源：
jQuery设计思想&mdash;阮一峰
jQuery中文文档
jQuery(选择器)用于获取对应的元素，但是它不返回对应的元素，
他返回一个对象，这个对象可以操作对应的元素。
jQuery获取页面元素 利用构造函数jQuery()（或者它的别称$），传入一个css选择器作为参数。
/*选取整个文档对象*/ $(document) /*选取id为xxx的网页元素*/ $('#xxx') /*选取class为xxxx的div元素*/ $('div.xxxx') /*选取name属性为first的input元素*/ $('input[name=first]')  也可以传入jQuery特有的选择器
/*选择网页第一个a元素*/ $('a:first') /*选择表格的奇数行*/ $('tr:odd') /*选择表单中的input元素*/ $('#myForm :input') /*选择可见的div元素*/ $('div:visible') /*选择所有的div元素，除了前三个*/ $('div:gt(2)') /*选择处于动画状态的div元素*/ $('div:animated')  链式操作 jQuery中的链式操作是通过jQuery对象调用jQuery函数，再次返回经过函数处理的jQuery对象实现的。
比如：
$('div').find('h3').eq(2).html('Hello');  $('div')返回一个对象，对象可以操作页面中的所有div；
.find('h3')返回一个对象,对象操作上述div对象中的所有h3元素；
.eq(2)返回一个对象，对象只操作上述h3元素的第三个；
.html('Hello')返回一个对象，该对象是将上述h3元素的内容更改为hello后的结果。
可以通过.end()回退一步。
可以通过链式操作对jQuery选择的元素进行更进一步的精确选择
// 选择包含p元素的div元素 $('div').has('p'); // 选择class不等于myclass的div元素 $('div').not('.myclass'); // 选择class等于myclass的div元素 $('div').filter('.myclass'); // 选择第一个div元素 $('div').first(); // 选择第六个div元素 $('div').eq(5); // 选择div元素后面的第一个p元素 $('div').next('p') // 选择div元素的父元素 $('div').parent() // 选择离div最近的form父元素 $('div').closest('form') // 选择div所有子元素 $('div').
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/for-in%E4%B8%8Efor-of/" class="link black dim">
        For In与for Of
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      版权声明：本文为周啟尧原创文章，著作权归本人所有，转载务必注明来源
参考文章
(for&hellip;in&hellip;与for&hellip;of&hellip;区别)[https://juejin.im/post/5b567b5a5188251ac0630bda]
for in更适合用来遍历对象，不要使用for in 遍历数组。
使用for in 遍历数组会产生以下问题：
1. JavaScript中的数组是用对象模拟出来的，数组的索引值也就是对象中的key，是字符串类型的数字。不能直接进行几何运算。
2. 使用for in遍历数组会遍历数组所有可枚举属性，包括原型。
3. 遍历的顺序可能不是按照数组实际的内部顺序。
for of 只是遍历数组中的元素，不包括数组的原型属性和索引。
for of遍历的是数组中的元素值，for in遍历的是索引。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/let%E5%92%8Cconst%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/" class="link black dim">
        Let和const在for循环中的运用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      版权声明：本文为周啟尧原创文章，著作权归本人所有，转载务必注明来源
参考资料来源：
(let const缓存for循环的中间变量)[https://juejin.im/post/5c6bb8566fb9a049f154c363]
(let 和 const 在for 循环中的使用)[https://www.cnblogs.com/SamWeb/p/10659352.html]
问题的根源起源于手写jQuery的过程中用到的代码：
find(selector) { let array = [] for (let i = 0; i &lt; elements.length; i++) { const elements2 = Array.from(elements[i].querySelectorAll(selector)) array = array.concat(elements2) } array.oldApi = this return jQuery(array) }  const关键字定义的变量不能被重新赋值，那它为什么可以出现在for循环中？
let 当我们在for循环中使用let时，每一次的迭代都会重新声明一次变量。比如for(let i = 0; i &lt; 10; i++)
i变量被声明了10次，每一次赋的值为上一次迭代完成时的值，这样的话，循环体内获取到的i，每次也都是全新的变量i，而不是像使用var声明时得到的是全局变量，并且每一次迭代完成后，i变量就消失了。
除了常规for循环，for-in和for-of同理。每一次迭代都是重新声明一个新的迭代对象，而不是给原来的迭代对象赋新值。
let arr = [1, 2, 3]; for (let key in arr) { console.log(key) } // 0 1 2 for(let key of arr){ console.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90html%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/" class="link black dim">
        谈谈浏览器解析html时的阻塞问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      参考文章：
DOM阻塞总结
深入浅出浏览器渲染原理
浏览器是如何解析html的？
浏览器阻塞
浏览器是如何工作的? 当我们在地址栏输入一个合法的URL后，浏览器首先进行域名解析，得到服务器的IP地址，然后浏览器会给服务器发送GET请求，等到服务器响应200后开始下载并解析html。
页面主要由DOM、CSS、JavaScript等部分构成，其中CSS和JavaScript既能内联也能以脚本的形式引入，此外还有img、iframe等其他资源，所有的这些资源都是通过dom标签的形式嵌入在html页面中，接下来我们分析一下dom的构建过程。
浏览器的工作流程  构建DOM =&gt; 构建CSSOM =&gt; 构建渲染树(Rendering Tree) =&gt; 布局(也叫回流) =&gt; 绘制
 大体来讲：
1. 浏览器会解析三个东西：
* HTML/SVG/XHTML，产生DOM Tree。
* CSS，产生CSS Rule Tree。
* JavaScript，脚本，通过DOM API 和CSSOM API操作DOM和CSSOM。
2. 解析完成后，结合DOM Tree和CSSOM Tree构造Rendering Tree。
* Rendering Tree和DOM Tree并不是完全相等的，比如Header和display：none就不会出现在Rendering Tree中。
* 将CSS Rule添加到Rendering Tree上的节点，然后计算每个元素的位置，这就是布局。
3. 调用操作系统Native GUI的API绘制。
DOM的构建过程 DOM的构建过程是顺序的，渐进式的。从第一行开始，逐行依次解析，并且会将已解析完成的部分显示出来。
如何判定DOM构建完成？
我们使用JavaScript操作DOM或者给DOM绑定事件的前提就是DOM树已经构建完成。当DOM树构建完成时，document对象会派发事件DOMContentLoaded来通知DOM树已经构建完成。
html从第一行开始解析，遇到外联资源(外联CSS、外联JS、image、iframe等)则会请求下载对应的资源。而其中有一部分会影响（阻塞）DOM的构建。
正常情况下CSSOM和DOM的构建是互不干扰的
浏览器下载HTML文件，解析HTML从而构建DOM。
遇到link[rel=stylesheet]时，将其加入下载队列，继续构建DOM。（CSS不会阻塞DOM的构建）
而JS的加载、解析和执行都会阻塞DOM的构建
当HTML解析器遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。
接下来具体分析。
CSSOM和DOM CSSOM和DOM的构建互不干扰，那么所有的CSS都不影响DOM的构建吗？
不是，这是有前提的。
前提是这些CSS样式不被JavaScript需要。
我们知道，JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。而不完整的CSSOM是无法使用的，因此如果JavaScript想访问CSSOM并更改它，必须要拿到完整的CSSOM，而JavaScript的加载、解析和执行都会阻塞DOM的构建，这样一来就导致了：
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/" class="link black dim">
        JS函数的执行时机
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      版权声明：本文为周啟尧原创文章，著作权归本人和饥人谷所有，转载务必注明来源
&mdash;以下文档部分转载自知乎文章《从一道面试题-计时器函数谈闭包》，作者：胡桃夹子
文章地址：https://zhuanlan.zhihu.com/p/80117819
/*********************/ let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(()=&gt;{ console.log(i) },0) } /*********************/  上述代码会打印出6个6。
为什么不是0、1、2、3、4、5？
原因是
setTimeout是一个计时器，设置时间为0秒。（计时0秒，相当于是马上要执行）
setTimeout是从队列结束的时候开始计时的，如果前面的进程没有结束，那么要等到前面的进程结束后才开始计时。在这里的任务队列就是它自己所在的循环。
意思是，执行完当前的代码之后立即执行计时器中的代码。而上面的&rdquo;当前代码&rdquo;就是指for循环。
在for循环执行完毕后，此时的i值等于6，才轮到setTimeout异步执行箭头函数。
6个setTimeout打印出当前的i值，执行结果就是打印6个6。
为了更好的理解，这里可以想象一个小场景。
 for循环想让setTimeout打印点东西，他说：boss给了我个任务，这个i是我第一次执行的结果，你打印给boss看看呗。(此时i=0)
setTimeout说：好的。然后他在便利贴上写道：打印i给老板看，放在了一边。（这里的i没有写明具体值）
for循环执行完第二遍又来根setTimeout说：这个i是我第二次执行的结果，你打印给boss看看呗。(此时i=1)
setTimeout又说：好的。然后他又在便利贴上写道：打印i给老板看，放在了第一张便利贴的下面。（这里的i没有写明具体值）
同样的情形发生了六次，在第六次的时候，for循环说：这个i是我的最终成果了，你打印一下。（i=6）
for循环的工作结束了，想起之前for循环安排的工作都没干，于是它找回之前的便利贴，一张一张执行。
每一张都写着&rdquo;打印i&rdquo;,于是setTimeout直接把i打印了6遍给boss。
 怎样才能让上述代码打印出0、1、2、3、4、5？
 利用闭包，用函数参数来保存i的值。
let i = 0 for(i = 0; i&lt;6; i++){ !function(i){ setTimeout(()=&gt;{ console.log(i) },0) }(i) }   上述代码中，for循环每一次循环，都会把i的值作为参数传给循环内的立即执行函数，再由立即执行函数把i的值传给setTimeout执行。
setTimeout与立即执行函数构成了闭包。
setTimeout每一次得到的参数来自立即执行函数。而立即执行函数每一次接受的i值不同，因此传给setTimeout的i值不同。
同样也是6个setTimeout，但setTimeout打印的i值来自立即执行函数，因此打印出0、1、2、3、4、5。
 对应上面的小场景。
这里相当于是在for循环和setTimeout之间安插了一位记录员function。
for循环每一次执行的版本（i的具体值）都会给function记录下来。
当setTimeout要执行的时候，会从function（而不是for循环）手中得到i的值。
 上面的代码还可以写成：
/*****************************/ let i = 0 for(i = 0; i&lt;6; i++){ setTimeout(!
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/js%E5%AF%B9%E8%B1%A1/" class="link black dim">
        JS对象
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      JavaScript的其中数据类型：四基两空一对象，今天我们来聊一聊对象Object，
以及原型是什么？
唯一的复杂类型——Object //常用写法： let obj = {'name':'xxx','age':'xxx',} //正规写法 let obj = new Object({'name':'xxx','age':'xxx'}) //匿名对象 console.log({'name':'xxx','age':'xxx'})  注意：
1. 键名是字符串，可以包含任何字符；
2. &ldquo;可以省略，但是省略后只能写标识符和数字；（所以为什么要省略它呢？写上！）
3. 对象没有所谓的数字下标，要得到对象中的某个值，只能通过它的键名获取。
4. 对象中的键值对又称为这个对象的属性。
let obj={ 1e2:'一百' } /*******结果是********/ obj = {'100':'一百'}  如果对象的键是一个表达式，那么JavaScript会将该表达式求值，并将结果转换为字符串。
提问：字符串是一个常量，我能不能用变量的值作为Object的键呢？ 答案是肯定的。
怎么做？
用&rsquo;[]&lsquo;将变量名包裹起来
let a = 'xxx' var obj = { [a] = 'hello' } /*******结果是********/ obj = {'xxx':'hello'}  同上面表达式的原理类似，JavaScript会先得到变量的值，再转为字符串。
Object中的增删查改 删除属性 delete obj.xxx 或 delete obj[&lsquo;xxx&rsquo;] ——删除obj对象的xxx属性
注意区分属性值为 undefined 和 不含属性名
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="link black dim">
        JS基本语法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      表达式和语句 表达式和语句的 一般 区别  表达式一般有值，语句可能有或没有；
 语句一般会改变环境（声明、赋值等）
 上述区别并不绝对。
  关于值和返回值
只有函数（表达式）才有返回值的概念。比如：
 1+2的值是3；
 add(1,2）表达式的值为函数的返回值
 console.log表达式的值为函数本身
 console.log(3)表达式的值为undefined（console.log没有返回值，打印出&rdquo;3&rdquo;是它的功能）
  注意事项  JavaScript中区分大小写；
 大部分空格没有意义；
 大部分回车没有意义（除了return，return后面不能随便回车，否则JavaScript会自动在return后面补上&rdquo;;&ldquo;）  标识符 命名规则
第一个字符后面可以接Unicode字符、&rdquo;$&ldquo;符号、&rdquo;_&ldquo;符号和中文，之后的字符除了这些之外，还可以是数字。
注释 多行注释 &ldquo;/**/&rdquo;
单行注释 &ldquo;//&rdquo;
好的注释：
/踩坑注解/
/为什么代码写的这么奇怪，遇到了什么bug/
条件语句 if&hellip;else&hellip; /************************/ if(表达式){ 语句1 }eles{ 语句2 } /************************/ if(表达式){ 语句1 }eles if{ 语句2 }else{ 语句3 } /************************/ function fn(){ if(){ return 表达式 } if(){ return 表达式 } return 表达式 } /************************/  注意
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/javascript%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/" class="link black dim">
        JavaScript的个人简历
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Javascript：我怎么来的？ JavaScript诞生于网景公司（_Mosaic Communications_）。
网景公司希望它们的浏览器能与使用者互动，要达成这一目的，他们需要一种网页脚本语言。
用什么语言来达成这一目的？要么，用当时现有的语言：python、perl、Scheme等；要么，开发一门新的语言。当时的网景公司分成了两派。
而同年发生了一件大事，Sun公司将Oak语言改名为Java，正式向市场推出，&rdquo;一次编写，到处运行&rdquo;的宣传语，使得Java很有可能成为未来的主宰。
网景公司看到了机会，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。
总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为&rdquo;Java+script&rdquo;并不是偶然的。
决定开发一种看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手的语言。为了使&rdquo;开发新语言&rdquo;这个提案站稳脚跟，这一种语言必须尽快出现，布兰登当时被指定为这门语言的设计师。
布兰登的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性。
而且，布兰登看不起Java。
1995年5月，布兰登仅花了10天时间就把这个拙劣的语言原型设计出来了。最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中部署时被重命名为JavaScript。
 布兰登的设计思路：
（1）借鉴C语言的基本语法；
（2）借鉴Java语言的数据类型和内存管理；
（3）借鉴Scheme语言，将函数提升到&rdquo;第一等公民&rdquo;（first class）的地位；
（4）借鉴Self语言，使用基于原型（prototype）的继承机制。
 Javascript语言实际上是两种语言风格的混合产物&mdash;-（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。
Javascript：我来到这个世界之后 JavaScript在浏览器推出后大受欢迎，微软为了与之对抗，开发了Jscript。Jscript可以认为是微软开发的JavaScript的翻版。两个版本在浏览器端共存意味着语言标准化的缺失。
网景公司为了取得先机，1996年11月率先向ECMA提交语言标准，1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。
Javascript：我为什么这么糟 从JavaScript上面的经历来看，我们不难找出原因。
 设计阶段过于仓促
  JavaScript的设计师仅仅用了10天就设计出JavaScript，而且设计师只是为了交差，本人并不愿意这样设计。
其次JavaScript设计的初衷是为了实现一些简单的页面交互，并没有考虑复杂应用的需要。
 没有先例  JavaScript同时结合了函数式编程和面向对象编程的特点，史无前例，直到现在为止，JavaScript仍然是世界上唯一使用prototype继承模型的语言，它并没有设计先例可以参考。
 过早的标准化  JavaScript发展迅速，没有时间优化设计。
1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。Javascript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。
更糟的是，Javascript的规格还没来及调整，就固化了。
1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请Javascript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。
也就是说，Javascript推出一年半之后，国际标准就问世了。设计缺陷还没有充分暴露就成了标准。相比之下，C语言问世将近20年之后，国际标准才颁布。
Javascript：我糟在哪？  不适合开发大型程序
 Javascript没有名称空间（namespace），很难模块化； 没有如何将代码分布在多个文件的规范； 允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。  非常小的标准库
  Javascript提供的标准函数库非常小，只能完成一些基本操作，很多功能都不具备。
 null和undefined  null属于对象（object）的一种，意思是该对象为空；undefined则是一种数据类型，表示未定义。
 全局变量难以控制  Javascript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://chow1027.xyz/posts/%E6%B5%85%E6%9E%90url/" class="link black dim">
        浅析URL
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      IP ——Internet Protocol 在说URL之前，先了解一下什么是IP。
IP是互联网协议（网络协议），他的作用是：
1. 约定如何定位一台设备（手机、电脑、网络摄像头等..）
2. 约定如何封装数据报文，用以与其他设备交流。
当我们要发文件、图片给互联网上的一台设备，我们就要知道这台设备的IP地址。
IP分为内网IP和外网IP。
内网IP由我们的路由器创建，我们的手机、电脑等设备连接到路由器，路由器会给我们的设备分配不同的内网IP。（内网IP的一般格式是192.168.xxx.xxx，一般路由器会给自己分配一个好记的内网IP，比如192.168.1.1）
有了内网IP。我们的设备之间就可以互相通信了，但要和外界进行交流，我们还需要一个外网IP。
外网IP是互联网服务提供商LSP（电信、移动等）的路由器给我们的路由器分配的一个IP。LSP可以理解是为一家管理一些特殊路由器的公司。
外网IP代表了我们在互联网中的地址，但它并固定，如果我们重启路由器，那么可能我们会被重新分配一个外网IP。
比方说当我们要登陆QQ邮箱时：
我们的登录信息先是经过了我们自家的路由器，然后经过调制解调器，然后到达LSP，LSP可能会连接到其他LSP路由器，我们的信息会到达QQ邮箱所使用的LSP路由器，最终再次通过调制解调器和路由器到达QQ邮箱的服务器。
 什么是调制解调器？
我们建立网络是为了我们自己的目的。所以不同的人会建立不同的网络：你的朋友，你的邻居，每个人都可以拥有自己的计算机网络。在你的房子和世界其它地方之间架设电缆将这些不同的网络连接起来是不可能的，那么你该如何处理这件事呢？其实已经有电缆连接到你的房子了，比如，电线和电话。电话基础设施已经可以把你家连接到世界的任何角落，所以它就是我们需要的线。为了连接电话这种网络我们需要一种基础设备叫做调制解调器（modem），调制解调器可以把网络信息变成电话设施可以处理的信息，反之亦然。
 资料来源：MDN:互联网是如何工作的？
如何查看IP？
通过ipconfig命令/通过ip138.com查询/ping命令（下面说）
端口号 有了IP，我们现在可以定位到互联网上的服务器。
但是还不够，我们还需要端口号。
因为一台设备可以提供很多服务，每个服务都对应一个号码，这个号码就是端口号。
 要提供HTTP服务最好使用80端口；
 要提供HTTPS服务最好使用443端口；
 要提供FTP服务最好使用21端口 一台机器可以有65535个端口  怎么知道什么时候该用什么端口？
维基百科搜索&rdquo;TCP 端口&rdquo;。快捷入口
注意端口的使用规则：
1. 0-1023号端口是留给系统使用的。
2. 只有拥有管理员权限才能使用这1024个端口。
3. 其他端口可以给普通用户使用。（比如http-server用的8080端口）
4. 一个端口被占用了，就只能用别的端口。
DNS ——Domain Name System 通过IP地址，我们就可以访问QQ邮箱、淘宝、京东，然后就使用里面的服务。
但是没那么简单。
因为IP地址是一串数字，它并不是那么容易记忆，于是人类发明了域名，用以直观的代表这个IP地址。
有了域名，我们现在就可以通过baidu.com访问百度主页，通过taobao.com访问淘宝主页，通过mail.qq.com访问qq邮箱。
我们人类知道了域名所对应的IP地址，那么计算机是怎么知道的呢？
答案是通过DNS。
DNS是域名系统，它类似于一本电话册，里面记录了每一个域名所对应的IP地址，每当我们访问一个域名，浏览器会先到DNS服务器询问这个域名对应的IP地址，然后再跳转到这个IP地址。
 DNS数据库存储在全球每个DNS服务器上，所有这些服务器都源于(refer to)几个被称为“权威名称服务器”或“顶级DNS服务器”。
 域名 我们知道了域名就是IP地址的别称，它们为互联网上任何可用的网页服务器提供了人类可读的地址。
域名有分级（以www.xiedaimala.com为例）
.com是顶级域名；
xiedaimala.com是二级域名（俗称一级域名）
www.xiedaimala.com是三级域名（俗称二级域名）
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://chow1027.xyz" >
    &copy; 2019 呆尬猴的博客
  </a>
    <div>











</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
