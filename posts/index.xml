<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 呆尬猴的博客</title>
    <link>https://chow1027.xyz/posts/</link>
    <description>Recent content in Posts on 呆尬猴的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 24 Apr 2020 00:20:52 +0800</lastBuildDate>
    
	<atom:link href="https://chow1027.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vue单向数据流与双向绑定</title>
      <link>https://chow1027.xyz/2020/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%90%97/</link>
      <pubDate>Fri, 24 Apr 2020 00:20:52 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%90%97/</guid>
      <description>单向绑定 &amp;amp; 双向绑定 单双向绑定，指的是 View 层与 Model 层之间的映射关系。
React React 采用单向绑定：用户访问 view，通过 dispatch 一个 action 对 state 进行更改，state 更新后触发 View 更新反馈给用户。
这就是单向绑定，View =&amp;gt; Action =&amp;gt; State =&amp;gt; View，View 不能直接修改 State。
Vue Vue 支持单向绑定：比如插值{{data}}，比如 v-bind
那你说 v-model 呢?
Vue 用 v-model 实现了双向绑定。
&amp;lt;input v-model=&amp;#34;something&amp;#34; /&amp;gt; 数据的流动方向： data 中的 something =&amp;gt; input 的 value =&amp;gt; 用户输入 =&amp;gt; 触发 input 事件 =&amp;gt; 被 Vue 实例监听到 =&amp;gt; 更新 data 中的 something。
v-model 是语法糖，上面可以写成
&amp;lt;input v-bind:value=&amp;#34;something&amp;#34; @input=&amp;#34;something = $event.</description>
    </item>
    
    <item>
      <title>实现typeof</title>
      <link>https://chow1027.xyz/2020/%E5%AE%9E%E7%8E%B0typeof/</link>
      <pubDate>Wed, 22 Apr 2020 10:07:46 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E5%AE%9E%E7%8E%B0typeof/</guid>
      <description>typeof 用来判断 JavaScript 中得基本数据类型，instanceof 用来判断 JavaScript 中的对象类型。
typeof 可以用 Object.prototype.toString() 实现。
Object.prototype.toString.call(1); // &amp;#34;[object Number]&amp;#34;  Object.prototype.toString.call(&amp;#34;hi&amp;#34;); // &amp;#34;[object String]&amp;#34;  Object.prototype.toString.call({ a: &amp;#34;hi&amp;#34; }); // &amp;#34;[object Object]&amp;#34;  Object.prototype.toString.call([1, &amp;#34;a&amp;#34;]); // &amp;#34;[object Array]&amp;#34;  Object.prototype.toString.call(true); // &amp;#34;[object Boolean]&amp;#34;  Object.prototype.toString.call(() =&amp;gt; {}); // &amp;#34;[object Function]&amp;#34;  Object.prototype.toString.call(null); // &amp;#34;[object Null]&amp;#34;  Object.prototype.toString.call(undefined); // &amp;#34;[object Undefined]&amp;#34;  Object.prototype.toString.call(Symbol(1)); // &amp;#34;[object Symbol]&amp;#34; </description>
    </item>
    
    <item>
      <title>实现new</title>
      <link>https://chow1027.xyz/2020/%E5%AE%9E%E7%8E%B0new/</link>
      <pubDate>Wed, 22 Apr 2020 00:37:08 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E5%AE%9E%E7%8E%B0new/</guid>
      <description>new 做了什么 其实 MDN 里面有写 当我们 new 一个构造函数的时候，new 实际上帮我们做了这么几件事情:
 自动创建空对象 自动为空对象关联原型，地址指定为【后面的】构造函数.prototype 自动将空对象作为 this 执行构造函数 自动 return this  new 实现 显然，如果我们不用 this，要构造一个对象实例会相当麻烦，我们可以尝试实现一下 new。
function myNew() { args = [...arguments]; let fn = args[0]; let arg = args.slice(1); if (typeof fn !== &amp;#34;function&amp;#34;) { console.log(&amp;#34;我接受一个函数！&amp;#34;); return; } // myNew.target = fn  let newObj = Object.create(fn.prototype); let result = fn.apply(newObj, arg); let isObject = typeof result === &amp;#34;object&amp;#34; &amp;amp;&amp;amp; result !</description>
    </item>
    
    <item>
      <title>EventLoop</title>
      <link>https://chow1027.xyz/2020/eventloop/</link>
      <pubDate>Tue, 21 Apr 2020 22:11:50 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/eventloop/</guid>
      <description>EventLoop 首先，EventLoop 是事件循环。浏览器的事件循环和 Node.js 的事件循环会稍有不同。下面会先介绍 Node.js 中的事件循环。
我们在 Node.js 官网里面可以看到：
其中，与前端密切相关的三个阶段 timers、poll、check。
当我们执行一段代码的时候，有时候会涉及到异步的代码，这时候就不得不提两个概念：宏任务和微任务。
一部分的异步代码会作为宏任务 push 到宏任务队列中，他们是：
 setTimeout setInterval setImmediate  而另一部分的代码则会作为微任务 push 到微任务队列，在 Node.js 中，主要就是指：
 process.nextTick  事件循环的过程 事件循环的过程可以简化为： timers &amp;gt; poll【等待阶段】 &amp;gt; check &amp;gt; timers
在 Node.js 中执行的代码，当遇到 setTimeout 的时候，setTimeout 的代码会被 push 到 timers 队列；当遇到 setImmediate 的时候，setImmediate 的代码则会 push 到 check 队列。
timers 阶段负责执行 timers 队列里面的代码；check 阶段也主要负责执行 check 队列的代码。
刚开始进入事件循环的时候，绝大部分的情况可能处于 poll 阶段【也有可能在 timers 阶段】。
在 poll 阶段的时候，他会等待 setTimeout 的执行时间，只要时间一到，就回去 timers 阶段执行代码。</description>
    </item>
    
    <item>
      <title>HTTP缓存</title>
      <link>https://chow1027.xyz/2020/http%E7%BC%93%E5%AD%98/</link>
      <pubDate>Thu, 16 Apr 2020 22:02:00 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/http%E7%BC%93%E5%AD%98/</guid>
      <description>HTTP 缓存首部字段  Cache-Control Pragma If-Match If-None-Match If-Modified-Since If-Unmodified-Since Etag Expires Last-Modified  总的来说，HTTP 缓存分为強缓存和协商缓存。
強缓存包括：Pragma，Expires，Cache-Control，用来决定是否缓存、缓存时间、缓存行为，他们的优先级顺序是：Pragma &amp;gt; Cache-Control &amp;gt; Expires。
协商缓存包括：Etag 和 Last-Modified，用来决定资源是否更新，是否使用缓存。
其中与 Etag 相关的两个字段是 If-Match，If-None-Match。
与 Last-Modified 相关的两个字段是 If-Modified-Since，If-UnModified-Since。
1. Pragma 通用首部字段，可以在请求报文和响应报文中使用。
当该字段为 no-cache 时，表示不要对该资源读取缓存，每次都要向服务器发送请求。
2. Expires 定义缓存过期的时间，由于是相对于服务器的时间而言，因此如果客户端的时间发生错乱就会出现问题（比如用户更改了系统时间）
3. Cache-Control 控制缓存行为。
与 Expires 不同，Cache-Control 定义的是过期时长，比如 max-age=3600 表示一小时后过期。
Cache-Control 具有多个选项，同时也是一个通用首部字段，可以在请求报文和响应报文中使用。
当作为请求首部时： no-cache 不直接使用缓存，向原服务器发起请求
no-store 所有内容都不会保存到缓存或 Internet 临时文件中
max-age 告知服务器客户端希望接受一个有效时间为 max-age 的资源
max-stale 告知服务器客户端愿意接受一个超过缓存时间为 max-scale 的资源
min-fresh 告知服务器表示客户端希望接受一个在 min-fresh 秒内被更新过的资源。</description>
    </item>
    
    <item>
      <title>数组扁平化的方法</title>
      <link>https://chow1027.xyz/2020/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 16 Apr 2020 10:04:56 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>数组扁平化 将数组[1,[2,3,[4,[5]]]]变成[1,2,3,4,5]就是数组扁平化。
方法一 es6 的新 api flat(depth) depth 默认是 1。
let a = [1, [2, 3, [4, [5]]]]; a.flat(); // [1, 2, 3, Array(2)] a.flat(4 - 1); // [1, 2, 3, 4, 5] 方法二 for 循环+concat let a = [1, [2, 3, [4, [5]]]]; function flatten(array) { let result = []; for (let i = 0; i &amp;lt; array.length; i++) { if (Array.isArray(array[i])) { result = result.concat(flatten(array[i])); } else { result.</description>
    </item>
    
    <item>
      <title>关于跨域的两种解决方案</title>
      <link>https://chow1027.xyz/2020/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 14 Apr 2020 17:33:54 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>浏览器为了保护用户隐私，设计了同源策略。即：不同源的页面之间不能互相访问数据。
什么是同源？即相同的协议、域名和端口号。
有时候我们需要获取别的网站的数据，这时候就需要用到跨域。这里主要说两种解决方案。
一、CORS 跨域资源共享 如果浏览器支持 CORS 就很简单。只需要后台在响应头里面设置一下即可：
response.setHeader(&amp;#34;Access-Control-Allow-Orogin&amp;#34;, &amp;#34;http:example.com:9999&amp;#34;); 不过 CORS 并不支持 IE6 7 8 9。。
如果需要兼容 IE，我们可以用 JSONP。
二、JSONP 虽说数据不能跨域，但 JS 文件是没有同源的限制的。我们大可把数据放到 JS 文件中。
具体怎么做呢？
首先，提供数据的一方需要做的是：
  将数据写到 JS 文件里。比如【data.js】
// 可以是赋值，也可以是函数  window[&amp;#39;{{xxx}}&amp;#39;]({{data}})   在收到这个 data.js 的请求的时候，获取 data.json 的数据，替换{{data}}；
  用 query 获取请求的参数【一般放在 callback 里面，是回调函数名。】用来替换{{xxx}}。
  然后将替换后的结果返回出去即可。
  else if(path=&amp;#34;/data.js&amp;#34;){ response.statusCode = 200; response.setHeader(&amp;#39;Content-Type&amp;#39;,&amp;#39;text/javascript;charset=utf-8&amp;#39;) const string = fs.readFileSync(&amp;#39;./public/friends.js&amp;#39;).toString() const data = fs.readFileSync(&amp;#39;./public/friends.json&amp;#39;).toString() /* 真正的数据 */ const string2 = string.</description>
    </item>
    
    <item>
      <title>尝试理解闭包</title>
      <link>https://chow1027.xyz/2020/%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sat, 04 Apr 2020 22:04:18 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E9%97%AD%E5%8C%85/</guid>
      <description>一些文章 我从来不理解 JavaScript 闭包，直到有人这样向我解释它&amp;hellip;
理解 JavaScript 中的闭包
什么是闭包？闭包的优缺点？
js 中闭包的理解、用途场景、优缺点及解决办法
一些概念 执行上下文
调用上下文
定义时上下文，运行时上下文
什么是闭包？闭包的用途是什么？闭包的缺点是什么？ 理解闭包是什么，我们先理解 JavaScript 的链式作用域：
在函数定义的时候就创建了链式作用域。
它的规则是：把函数本身的变量优先级放在最前面，把自身的父级函数中的变量放在其次，在把高一级函数中的变量放在更后面，依次类推直到全局变量为止。
当这个函数需要某个变量的时候，会沿着链式作用域逐级寻找，并在找到的里函数最近的一级停下，如果找不到就会返回 undefined。
由于链式作用域的机制，会导致： 一个函数可以读取函数外部的变量，但在函数外部无法读取函数内部的变量。
而当一个函数访问了函数外部的变量时，我们称这个函数和变量构成了闭包。
function father() { let a = 100; function children() { console.log(a); } return children; } let child = father(); child(); // 100 执行上述代码，首先会调用 father 函数，调用的结果是返回一个 children 函数的定义给变量 child。
执行变量 child 中的 children 函数的定义（也就是 children 函数{}包裹的代码块），执行过程中要打印 a，children。
函数中没有 a 的定义，因此会沿着链式作用域向上级寻找，打印了 father 函数下的 a。
换种方式理解，闭包包含了函数本身以及函数被创建时所处的环境（这里的环境是指函数创建时所在作用域的所有变量）。
上述代码中，传递给 child 的除了 children 的函数定义以外，还携带了 children 在被创建时的环境（也就是 let a = 100）。</description>
    </item>
    
    <item>
      <title>四种排序算法</title>
      <link>https://chow1027.xyz/2020/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 26 Feb 2020 15:14:02 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E6%8E%92%E5%BA%8F/</guid>
      <description>给出正整数数组 array = [2,1,5,3,8,4,9,5] 请写出一个函数 sort，使得 sort(array) 得到从小到大排好序的数组 [1,2,3,4,5,5,8,9] 新的数组可以是在 array 自身上改的，也可以是完全新开辟的内存。
不得使用 JS 内置的 sort API
快速排序 let quicksort = (numbers) =&amp;gt; { if (numbers.length &amp;lt; 2) { return numbers; } let pivotindex = Math.floor(numbers.length / 2); let pivotnum = numbers.splice(pivotindex, 1)[0]; let left = []; let right = []; for (i = 0; i &amp;lt; numbers.length; i++) { if (numbers[i] &amp;lt;= pivotnum) { left.push(numbers[i]); } else { right.push(numbers[i]); } } return quicksort(left).</description>
    </item>
    
    <item>
      <title>四种数组去重的方法</title>
      <link>https://chow1027.xyz/2020/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Wed, 05 Feb 2020 23:53:58 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>如何实现数组去重？ 假设有数组 array = [1,5,2,3,4,2,3,1,3,4] 写一个 unique 函数去重
ES6 set 去重（ES6 中最常用） function unique(arr) { return Array.from(new Set(arr)); } let array = [1, 5, 2, 3, 4, 2, 3, 1, 3, 4]; console.log(unique(array)); // [1, 5, 2, 3, 4] 缺点：这个方法不能去掉重复的空数组{}。
var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}]; console.log(unique(arr)) // [1, &amp;quot;true&amp;quot;, true, 15, false, undefined, null, NaN, &amp;quot;NaN&amp;quot;, 0, &amp;quot;a&amp;quot;, {}, {}] 利用 Map 数据结构 function unique(array) { let hashMap = new Map(); // 用于判别是否重复  let result = new Array(); // 用于返回结果  for (let i = 0; i &amp;lt; array.</description>
    </item>
    
    <item>
      <title>代码可读性与代码优化</title>
      <link>https://chow1027.xyz/2020/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</link>
      <pubDate>Sun, 19 Jan 2020 21:10:16 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2020/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</guid>
      <description>优化原则 工作中，尤其是在一个团队里面我们的代码常常是要写给别人看的，因此如果不是遇到性能瓶颈，我们应该优先考虑代码的易读性。
而无论我们如何对代码作出优化，逻辑的复杂度始终是不会改变的，如果实现需求本身的逻辑是复杂的，那么代码看起来就应该是复杂的，如果逻辑是简单的，那么代码看起来也应该是简单的。
变量命名 词性  普通的变量/属性：名词 // 不要使用a b c等没有意义的变量名 let person = { name: &amp;#34;jack&amp;#34;, age: &amp;#34;18&amp;#34;, };  布尔类型的变量/属性：形容词/be 动词/情态动词/{hasX} // 形容词 dead:false // be动词 canListen:true // 情态动词 - can isTeacher:true // hasXxx hasChildren:true  普通函数/方法：动词 run() drinkTea() eat(fruit){}  回调，钩子函数：用介词开头/动词的现在完成时 // Vue就是一个很好的例子 created(){} beforeMount(){} mounted(){} beforeUpdate(){} updated(){} ...  巧用前缀 // DOM对象 加 el 前缀 // jQuery对象 加 $ 前缀 elDiv1.classList.add(&amp;#34;active&amp;#34;); $div2.addClass(&amp;#34;active&amp;#34;);   一致性  介词一致性</description>
    </item>
    
    <item>
      <title>变量声明：let、const、var</title>
      <link>https://chow1027.xyz/2019/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</link>
      <pubDate>Sat, 28 Dec 2019 16:08:31 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</guid>
      <description>a = 1 var a = 1 let a = 1 const a = 1 a = 1 var a // a1 全局变量 function fn(){ var a // a2 局部变量  function fn2(){ a = 1 // 如果没有a1 a2，就声明一个全局变量a  // 如果没有a1，就用a2  // 如果没有a2.就用a1  // 如果a1 a2都有，就近原则，用a2  } } 如果当前有a，就直接利用这个a，如果当前没有a，就声明一个全局变量a。
变量提升 function fn(){ // {{a}}  if(true){ console.log(a) }else{ // 这里不会执行  var a = 1 console.log(2) } } // undefined 代码没有报错，原因是var会变量提升。它最终会提到{{a}}的位置中去。</description>
    </item>
    
    <item>
      <title>Vue:数据响应式</title>
      <link>https://chow1027.xyz/2019/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</link>
      <pubDate>Fri, 20 Dec 2019 20:56:13 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</guid>
      <description>前言 先说两个基本的认识
响应式：若某个东西能对外界的变化(刺激)做出反应，那么他就是响应式的。
比如响应式页面，就是当我们改变窗口的大小时，网页内容会根据窗口的大小做出反应(调整)的页面。
数据响应式：
Vue 的 data 是响应式的。比如const vm = new Vue({data:{n:0}})，
如果修改 vm.n(或 data.n)，那么页面中的 n 就会作出响应，渲染为对应的 n 或者经过一些数据处理后的 n。
这就是响应式
Vue2 通过 Object.defineProperty 实现数据响应式。
接下来，先理解下面两个 ES6 语法，有助于本文的阅读。
1. getter/setter
现有如下对象
let obj = { firstName: &amp;#34;张&amp;#34;, lastName: &amp;#34;三&amp;#34;, name() { return this.firstName + this.lastName; }, }; console.log(obj.name()); // 张三 通过调用obj 的 name 函数就可以得到这个对象的姓名。
 getter/setter  let obj = { firstName:&amp;#39;张&amp;#39;, lastName:&amp;#39;三&amp;#39;, get name(){ return this.firstName + this.lastName }, set name(arr){ this.</description>
    </item>
    
    <item>
      <title>如何理解Vue的.Sync修饰符</title>
      <link>https://chow1027.xyz/2019/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Fri, 20 Dec 2019 20:56:13 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>有时候我们可能需要对一个 prop 进行双向绑定，但真正的双向绑定会带来维护上的问题。
因为子组件可以修改父组件，且在子组件和父组件都没有明显的改动来源。
因此 Vue 推荐以update:myPropName的模式触发事件取代双向绑定。
具体做法就是：首先在子组件中用$emit 传递参数。
&amp;quot;update:title&amp;quot;是事件名，newTitle 是传递给父组件的参数。// 子组件 this.$emit(&amp;#39;update:title&amp;#39;,newTitle) 然后在父组件监听&amp;quot;update:title&amp;quot;事件，根据需要更新父组件上的数据属性。
// 父组件 &amp;lt;text-document v-bind:title=&amp;#34;doc.title&amp;#34; v-on:update:title=&amp;#34;doc.title=$event&amp;#34;&amp;gt; &amp;lt;/text-document&amp;gt; 上面的模式很常见，于是 Vue 给这种模式提供给了缩写，就是.sync 修饰符。
// 父组件 &amp;lt;text-document :title.sync=&amp;#34;doc.title&amp;#34;&amp;gt;&amp;lt;/text-document&amp;gt; // 相当于 //&amp;lt;text-document // v-bind:title=&amp;#34;doc.title&amp;#34; // v-on:update:title=&amp;#34;doc.title=$event&amp;#34;&amp;gt; //&amp;lt;/text-document&amp;gt; 当我们需要在子组件上修改 props 传递的数据时，不能直接修改，而是要通过.sync 修饰符，通知父组件修改。
案例 比如设想一个这样的场景：爸爸给儿子钱，儿子要花钱。
父亲组件
首先，爸爸要告诉儿子自己有多少钱（用 v-bind:），同时爸爸要儿子在花完钱之后(v-on:&amp;lsquo;儿子花钱事件&amp;rsquo;)，把余额还给自己(用$event)
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;father&amp;#34;&amp;gt; 我现在有 {{fatherMoney}} &amp;lt;/div&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;Child :money=&amp;#34;fatherMoney&amp;#34; v-on:update:money=&amp;#34;fatherMoney = $event&amp;#34; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import Child from &amp;#34;./Child.vue&amp;#34;; export default{ data(){ return {fatherMoney:10000}; }, components:{Child:Child} }; &amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; .</description>
    </item>
    
    <item>
      <title>Vue:完整版和非完整版</title>
      <link>https://chow1027.xyz/2019/vue%E5%AE%8C%E6%95%B4%E7%89%88%E5%92%8C%E9%9D%9E%E5%AE%8C%E6%95%B4%E7%89%88/</link>
      <pubDate>Thu, 19 Dec 2019 20:51:28 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/vue%E5%AE%8C%E6%95%B4%E7%89%88%E5%92%8C%E9%9D%9E%E5%AE%8C%E6%95%B4%E7%89%88/</guid>
      <description>Vue 有两个版本，完整版和非完整版，非完整版也称为运行时版本。
完整版的文件名为：vue.js；非完整版的文件名为 vue.runtime.js；这两个文件里面包含了注释。
如果是在生产环境，我们可以使用 vue.min.js 和 vue.runtime.min.js，这是完整版和非完整版去除了注释以及压缩后的版本，相对于原来体积会变小。
完整版 VS 非完整版 完整版 = 运行时 + 编译器 compiler
由于编译器的存在，完整版比运行时版本体积大 40%左右。
编译器干嘛的？？
完整版 Vue 内置了编译器，它可以直接从 HTML 获取元素，得到视图。
比如
new Vue({ el: &amp;#34;#app&amp;#34;, }); 就可以得到这个 HTML 中 id 为 app 的节点，
或者通过 template
new Vue({ el: &amp;#34;#app&amp;#34;, template: ` &amp;lt;div&amp;gt;{{n}}&amp;lt;/div&amp;gt; `, data: { n: 0, }, }); 如果使用非完整版，我们要使用 JS 构建视图，在 render 函数里面用 h 创建标签。
比如：
new Vue({ el:&amp;#39;#app&amp;#39;, render(h){ return h(&amp;#39;div&amp;#39;,this.n) }, data:{ n:0 } }) h 相当于 createElement，render 函数返回了一个 div 节点，里面的内容是 n。</description>
    </item>
    
    <item>
      <title>MVC:拒绝面条式代码</title>
      <link>https://chow1027.xyz/2019/mvc/</link>
      <pubDate>Sat, 14 Dec 2019 19:08:42 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/mvc/</guid>
      <description>设计模式概述 设计模式是我们在进行程序设计的过程中，对普遍存在的问题（或反复出现的情况）提出的一种统一的解决方案。
比如适配器模式、Promise、重载、别名、getter/setter、观察者模式等。
代码模块化 如果代码中存在一些可以具体实现某些功能的代码块，而这些代码块的功能在其他的地方也可以适用。
那么我们可以将这部分代码可以封装成一个函数、一个类，这就是代码的模块化；
根据操作对象的不同，比如将专门操作 DOM 对象的代码放在一类，将专门负责页面渲染更新的代码当在一类，这也是代码的模块化。
就是说，总是会有&amp;quot;万金油&amp;quot;的代码，是所有项目或块的通用代码，我们将这些具有相同&amp;quot;目的&amp;quot;的代码整合成一个模块，就可以使代码的整体结构更加清晰
模块之间虽然有联系，但每个模块只需关注自身的执行情况以及传进来的参数即可，不会牵一发而动全身，这也是一种解耦的思想。
MVC 设计模式 MVC 是设计模式的一种，是我们优化代码结构的一种方案。同时，他也是代码模块化的一种体现。
它不直接指导具体代码的实现，而是从全局的、宏观的角度，指导各个部分的代码应该怎么“摆”，从而使代码整体结构更加规律、直观。
当需求越是复杂，要实现的功能越复杂的时候，MVC 所带来的好处就越明显。
MVC 把代码的结构分成三个部分：Model-数据、View-视图、Control-控制器。
Model 数据 Model 负责代码中的所有与数据相关的部分，比如数据的更新、数据的读取、数据的存储等。
它不依赖于 View 和 Control，也就是说，它并不关心数据会被如何显示，或是被如何处理，它只需要管理好它的数据即可。
以下面的 Model 举例:
class Model { constructor(options) { // 接受数据  const keys = [&amp;#34;data&amp;#34;, &amp;#34;update&amp;#34;, &amp;#34;create&amp;#34;, &amp;#34;delete&amp;#34;, &amp;#34;get&amp;#34;]; keys.forEach((key) =&amp;gt; { if (key in options) { this[key] = options[key]; } }); } // 各种数据相关的方法  create() {} delete() {} update() {} get() {} } View 视图 View 负责处理用户界面相关的代码，比如页面的重新渲染。</description>
    </item>
    
    <item>
      <title>事件流与事件委托</title>
      <link>https://chow1027.xyz/2019/%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</link>
      <pubDate>Sun, 08 Dec 2019 19:43:20 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</guid>
      <description>事件流 事件流就是页面中的元素接受事件的顺序。
可以分为事件冒泡流、事件捕获流。
事件冒泡流 &amp;amp;&amp;amp; 事件捕获流 事件冒泡流是从事件开始的具体元素，逐级往上传播到较为不具体的节点。
最外面的节点是 window！！！！
比如
&amp;lt;body&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;here&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; 当点击 p 元素时，事件冒泡流的传播顺序是：
p &amp;gt; div &amp;gt; body &amp;gt; html &amp;gt; document &amp;gt; window
事件捕获流与事件冒泡流恰好相反，它的传播顺序是：
window &amp;gt; document &amp;gt; html &amp;gt; body &amp;gt; div &amp;gt; p
在事件到达预定目标之前捕获它。
DOM 二级事件 DOM 二级事件规定：事件流分为三个阶段：事件捕获阶段，处于目标阶段，事件冒泡阶段。
首先发生事件捕获，事件在到达目标后停止。 然后是处于目标，事件在目标上发生，并在事件处理中被看成是冒泡阶段的一部分，最后事件再冒泡传播至 document。
什么是事件委托？ 每一个函数都是一个对象，都会占用内存。内存中的对象越多，性能就越差，事件处理程序过多的解决方案就是事件委托。
把原本需要绑定在子元素的响应事件委托给它的父元素，让父元素承担监听事件的任务。
事件委托的原理就是利用了事件冒泡。
比如有这么个结构：div &amp;gt; ul &amp;gt; li &amp;gt; a，我们可以给 div 添加点击事件，那么当 div 中的 ul、li、a 做点击事件的时候，会冒泡到最外层的 div，触发 div 上的点击事件。
举例说明：</description>
    </item>
    
    <item>
      <title>Promise</title>
      <link>https://chow1027.xyz/2019/promise/</link>
      <pubDate>Sun, 08 Dec 2019 12:26:39 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/promise/</guid>
      <description>Promise Promise 是目前前端异步编程的一个解决方案。
它解决了回调地狱的问题，规范了回调的名字和顺序，同时也方便了捕获错误。
一个 Promise 有三种状态：
pending：表示初始状态，既没有成功，也没有失败
fulfilled 表示操作成功完成
rejected 表示操作失败。
创建一个 Promise // 直接用Promise构造函数创建一个Promise对象 let promiseFn = new Promise((resolve,reject)=&amp;gt;{}) // 也可以在回调的异步函数的第一行加上下面这句代码 function promiseFn(){ return new Promise((resolve,reject)=&amp;gt;{...}) } Promise.then() Promise.then()接受两个回调函数，第一个为成功回调，第二个为失败回调。
var p1 = new Promise((resolve, reject) =&amp;gt; { resolve(&amp;#34;成功！&amp;#34;); // or  // reject(new Error(&amp;#34;出错了！&amp;#34;)); }); p1.then( (value) =&amp;gt; { console.log(value); // 成功！  }, (reason) =&amp;gt; { console.error(reason); // 出错了！  } ); Promise.all() 接受多个 Promise 组成的可迭代对象，比如数组。返回结果是一个新的 Promise 对象。</description>
    </item>
    
    <item>
      <title>常用http状态码</title>
      <link>https://chow1027.xyz/2019/%E5%B8%B8%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Thu, 05 Dec 2019 23:48:07 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E5%B8%B8%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>## 2xx ： 成功 #### 表示成功处理了请求的状态代码。 200 **成功** 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 201 **已创建** 请求成功并且服务器创建了新的资源。 202 **已接受** 服务器已接受请求，但尚未处理。 203 **非授权信息** 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 **无内容** 服务器成功处理了请求，但没有返回任何内容。 205 **重置内容**服务器成功处理了请求，但没有返回任何内容。 206 **部分内容** 服务器成功处理了部分 GET 请求。 ## 3xx ： 重定向 #### 表示要完成请求，需要进一步操作。通常，以下状态代码用来重定向。 300 **多种选择** 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 **永久移动** 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 **临时移动** 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 **查看其他位置**请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 **未修改**自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 **使用代理**请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 **临时重定向** 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 ## 4xx：请求错误 ### 以下状态代码表示请求可能出错，妨碍了服务器的处理。 400 **错误请求**服务器不理解请求的语法。 401 **未授权**请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 403 **禁止**服务器拒绝请求。 404 **未找到**服务器找不到请求的网页。 405 **方法禁用**禁用请求中指定的方法。 406 **不接受**无法使用请求的内容特性响应请求的网页。 407 **需要代理授权**此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 **请求超时** 服务器等候请求时发生超时。 409 **冲突** 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 **已删除** 如果请求的资源已永久删除，服务器就会返回此响应。 411 **需要有效长度**服务器不接受不含有效内容长度标头字段的请求。 412 **未满足前提条件**服务器未满足请求者在请求中设置的其中一个前提条件。 413 **请求实体过大**服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 **请求的 URI 过长**请求的 URI（通常为网址）过长，服务器无法处理。 415 **不支持的媒体类型**请求的格式不受请求页面的支持。 416 **请求范围不符合要求**如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 **未满足期望值**服务器未满足&amp;#34;期望&amp;#34;请求标头字段的要求。 ## 5xx：服务器错误 ### 以下状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500 **服务器内部错误** 服务器遇到错误，无法完成请求。 501 **尚未实施**服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 **错误网关**服务器作为网关或代理，从上游服务器收到无效响应。 503 **服务不可用**服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 **网关超时** 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 **HTTP 版本不受支持**服务器不支持请求中所用的 HTTP 协议版本。 </description>
    </item>
    
    <item>
      <title>Axios使用手册</title>
      <link>https://chow1027.xyz/2019/axios%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</link>
      <pubDate>Tue, 03 Dec 2019 18:45:06 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/axios%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</guid>
      <description>参考文献：
axios中文网
axios英文原文
GET 请求 /*为给定 ID 的 User 创建请求*/ axios.get(&amp;#39;/user?ID = 12345&amp;#39;) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) /*可以通过对象传递 User 的 ID*/ axios.get(&amp;#39;/user&amp;#39;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) POST 请求 /*执行post请求*/ axios.post(&amp;#39;user&amp;#39;,{ firstName:&amp;#39;Fred&amp;#39;, lastName:&amp;#39;Flintstone&amp;#39; }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) 执行多个并发请求 function getUserAccount(){ return axios.get(&amp;#39;/user/12345&amp;#39;); } function getUserPermissions(){ return axios.get(&amp;#39;/user/12345/permissions&amp;#39;); } axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms){ // 两个请求现在都执行完成  })); 创建请求 /*发送POST请求*/ axios({ method:&amp;#39;post&amp;#39;, url:&amp;#39;/user/12345&amp;#39;, data:{ firstName:&amp;#39;Fred&amp;#39;, lastName:&amp;#39;Flintstone&amp;#39; } }); /*获取远端照片*/ axios({ method:&amp;#39;get&amp;#39;, url:&amp;#39;http://bit.</description>
    </item>
    
    <item>
      <title>JQuery中的函数</title>
      <link>https://chow1027.xyz/2019/jquery%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 30 Nov 2019 18:52:19 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/jquery%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>一些文章 jQuery 设计思想&amp;mdash;阮一峰
jQuery 中文文档
正文 jQuery(选择器)用于获取对应的元素，但是它不返回对应的元素，
他返回一个对象，这个对象可以操作对应的元素。
jQuery 获取页面元素 利用构造函数 jQuery()（或者它的别称$），传入一个 css 选择器作为参数。
/*选取整个文档对象*/ $(document) /*选取id为xxx的网页元素*/ $(&amp;#39;#xxx&amp;#39;) /*选取class为xxxx的div元素*/ $(&amp;#39;div.xxxx&amp;#39;) /*选取name属性为first的input元素*/ $(&amp;#39;input[name=first]&amp;#39;) 也可以传入 jQuery 特有的选择器
/*选择网页第一个a元素*/ $(&amp;#39;a:first&amp;#39;) /*选择表格的奇数行*/ $(&amp;#39;tr:odd&amp;#39;) /*选择表单中的input元素*/ $(&amp;#39;#myForm :input&amp;#39;) /*选择可见的div元素*/ $(&amp;#39;div:visible&amp;#39;) /*选择所有的div元素，除了前三个*/ $(&amp;#39;div:gt(2)&amp;#39;) /*选择处于动画状态的div元素*/ $(&amp;#39;div:animated&amp;#39;) 链式操作 jQuery 中的链式操作是通过 jQuery 对象调用 jQuery 函数，再次返回经过函数处理的 jQuery 对象实现的。
比如：
$(&amp;#39;div&amp;#39;).find(&amp;#39;h3&amp;#39;).eq(2).html(&amp;#39;Hello&amp;#39;); $(&#39;div&#39;)返回一个对象，对象可以操作页面中的所有 div；
.find(&#39;h3&#39;)返回一个对象,对象操作上述 div 对象中的所有 h3 元素；
.eq(2)返回一个对象，对象只操作上述 h3 元素的第三个；
.html(&#39;Hello&#39;)返回一个对象，该对象是将上述 h3 元素的内容更改为 hello 后的结果。
可以通过.end()回退一步。
可以通过链式操作对 jQuery 选择的元素进行更进一步的精确选择
// 选择包含p元素的div元素 $(&amp;#39;div&amp;#39;).</description>
    </item>
    
    <item>
      <title>For In与for Of</title>
      <link>https://chow1027.xyz/2019/for-in%E4%B8%8Efor-of/</link>
      <pubDate>Wed, 27 Nov 2019 06:52:50 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/for-in%E4%B8%8Efor-of/</guid>
      <description>参考 for&amp;hellip;in&amp;hellip;与 for&amp;hellip;of&amp;hellip;区别
正文 for in 更适合用来遍历对象，不要使用 for in 遍历数组。
使用 for in 遍历数组会产生以下问题：
  JavaScript 中的数组是用对象模拟出来的，数组的索引值也就是对象中的 key，是字符串类型的数字。不能直接进行几何运算。
  使用 for in 遍历数组会遍历数组所有可枚举属性，包括原型。
  遍历的顺序可能不是按照数组实际的内部顺序。
  for of 只是遍历数组中的元素，不包括数组的原型属性和索引。
for of 遍历的是数组中的元素值，for in 遍历的是索引。</description>
    </item>
    
    <item>
      <title>Let和const在for循环中的运用</title>
      <link>https://chow1027.xyz/2019/let%E5%92%8Cconst%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</link>
      <pubDate>Wed, 27 Nov 2019 06:12:07 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/let%E5%92%8Cconst%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</guid>
      <description>一些文章 let const 缓存 for 循环的中间变量
let 和 const 在 for 循环中的使用
正文 问题的根源起源于手写 jQuery 的过程中用到的代码：
find(selector) { let array = [] for (let i = 0; i &amp;lt; elements.length; i++) { const elements2 = Array.from(elements[i].querySelectorAll(selector)) array = array.concat(elements2) } array.oldApi = this return jQuery(array) } const 关键字定义的变量不能被重新赋值，那它为什么可以出现在 for 循环中？
let 当我们在 for 循环中使用 let 时，每一次的迭代都会重新声明一次变量。比如for(let i = 0; i &amp;lt; 10; i++)
i 变量被声明了 10 次，每一次赋的值为上一次迭代完成时的值，
这样的话，循环体内获取到的 i，每次也都是全新的变量 i，而不是像使用 var 声明时得到的是全局变量，并且每一次迭代完成后，i 变量就消失了。</description>
    </item>
    
    <item>
      <title>谈谈浏览器解析html时的阻塞问题</title>
      <link>https://chow1027.xyz/2019/%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90html%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 25 Nov 2019 13:33:43 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90html%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/</guid>
      <description>一些文章 DOM 阻塞总结
深入浅出浏览器渲染原理
浏览器是如何解析 html 的？
浏览器阻塞
浏览器是如何工作的? 当我们在地址栏输入一个合法的 URL 后，浏览器首先进行域名解析，得到服务器的 IP 地址，然后浏览器会给服务器发送 GET 请求，等到服务器响应 200 后开始下载并解析 html。
页面主要由 DOM、CSS、JavaScript 等部分构成，其中 CSS 和 JavaScript 既能内联也能以脚本的形式引入，此外还有 img、iframe 等其他资源，所有的这些资源都是通过 dom 标签的形式嵌入在 html 页面中，接下来我们分析一下 dom 的构建过程。
浏览器的工作流程  构建 DOM =&amp;gt; 构建 CSSOM =&amp;gt; 构建渲染树(Rendering Tree) =&amp;gt; 布局(也叫回流) =&amp;gt; 绘制
 大体来讲：
 浏览器会解析三个东西：  HTML/SVG/XHTML，产生 DOM Tree。 CSS，产生 CSS Rule Tree。 JavaScript，脚本，通过 DOM API 和 CSSOM API 操作 DOM 和 CSSOM。   解析完成后，结合 DOM Tree 和 CSSOM Tree 构造 Rendering Tree。  Rendering Tree 和 DOM Tree 并不是完全相等的，比如 Header 和 display：none 就不会出现在 Rendering Tree 中。 将 CSS Rule 添加到 Rendering Tree 上的节点，然后计算每个元素的位置，这就是布局。   调用操作系统 Native GUI 的 API 绘制。  DOM 的构建过程 DOM 的构建过程是顺序的，渐进式的。从第一行开始，逐行依次解析，并且会将已解析完成的部分显示出来。</description>
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>https://chow1027.xyz/2019/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Mon, 18 Nov 2019 15:18:59 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      <description>一些文章 &amp;mdash;以下文档部分转载自知乎文章《从一道面试题-计时器函数谈闭包》，作者：胡桃夹子
文章地址：https://zhuanlan.zhihu.com/p/80117819
正文 /*********************/ let i = 0 for(i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) } /*********************/ 上述代码会打印出 6 个 6。
为什么不是 0、1、2、3、4、5？
原因是
setTimeout 是一个计时器，设置时间为 0 秒。（计时 0 秒，相当于是马上要执行）
setTimeout 是从队列结束的时候开始计时的，如果前面的进程没有结束，那么要等到前面的进程结束后才开始计时。在这里的任务队列就是它自己所在的循环。
意思是，执行完当前的代码之后立即执行计时器中的代码。而上面的&amp;quot;当前代码&amp;quot;就是指 for 循环。
在 for 循环执行完毕后，此时的 i 值等于 6，才轮到 setTimeout 异步执行箭头函数。
6 个 setTimeout 打印出当前的 i 值，执行结果就是打印 6 个 6。
为了更好的理解，这里可以想象一个小场景。
 for 循环想让 setTimeout 打印点东西，他说：boss 给了我个任务，这个 i 是我第一次执行的结果，你打印给 boss 看看呗。(此时 i=0)
setTimeout 说：好的。然后他在便利贴上写道：打印 i 给老板看，放在了一边。（这里的 i 没有写明具体值）</description>
    </item>
    
    <item>
      <title>JS对象</title>
      <link>https://chow1027.xyz/2019/js%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 16 Nov 2019 14:41:49 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%AF%B9%E8%B1%A1/</guid>
      <description>JavaScript 的其中数据类型：四基两空一对象。
今天我们来聊一聊对象 Object，以及原型是什么？
唯一的复杂类型——Object //常用写法： let obj = {&amp;#39;name&amp;#39;:&amp;#39;xxx&amp;#39;,&amp;#39;age&amp;#39;:&amp;#39;xxx&amp;#39;,} //正规写法 let obj = new Object({&amp;#39;name&amp;#39;:&amp;#39;xxx&amp;#39;,&amp;#39;age&amp;#39;:&amp;#39;xxx&amp;#39;}) //匿名对象 console.log({&amp;#39;name&amp;#39;:&amp;#39;xxx&amp;#39;,&amp;#39;age&amp;#39;:&amp;#39;xxx&amp;#39;}) 注意：
 键名是字符串，可以包含任何字符； &amp;lsquo;&amp;lsquo;可以省略，但是省略后只能写标识符和数字；（所以为什么要省略它呢？写上！） 对象没有所谓的数字下标，要得到对象中的某个值，只能通过它的键名获取。 对象中的键值对又称为这个对象的属性。  let obj={ 1e2:&amp;#39;一百&amp;#39; } /*******结果是********/ obj = {&amp;#39;100&amp;#39;:&amp;#39;一百&amp;#39;} 如果对象的键是一个表达式，那么 JavaScript 会将该表达式求值，并将结果转换为字符串。
提问：字符串是一个常量，我能不能用变量的值作为 Object 的键呢？ 答案是肯定的。
怎么做？
用&amp;rsquo;[]&amp;lsquo;将变量名包裹起来
let a = &amp;#39;xxx&amp;#39; var obj = { [a] = &amp;#39;hello&amp;#39; } /*******结果是********/ obj = {&amp;#39;xxx&amp;#39;:&amp;#39;hello&amp;#39;} 同上面表达式的原理类似，JavaScript 会先得到变量的值，再转为字符串。
Object 中的增删查改 删除属性 delete obj.xxx 或 delete obj[&amp;lsquo;xxx&amp;rsquo;] ——删除 obj 对象的 xxx 属性</description>
    </item>
    
    <item>
      <title>JS基本语法</title>
      <link>https://chow1027.xyz/2019/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 15 Nov 2019 06:40:40 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>表达式和语句 表达式和语句的 &amp;ldquo;一般&amp;rdquo; 区别  表达式一般有值，语句可能有或没有； 语句一般会改变环境（声明、赋值等） 上述区别并不绝对。  关于值和返回值
只有函数（表达式）才有返回值的概念。比如：
 1+2的值是 3； add(1,2）表达式的值为函数的返回值 console.log表达式的值为函数本身 console.log(3)表达式的值为 undefined（console.log 没有返回值，打印出&amp;quot;3&amp;quot;是它的功能）  注意事项  JavaScript 中区分大小写； 大部分空格没有意义； 大部分回车没有意义（除了 return，return 后面不能随便回车，否则 JavaScript 会自动在 return 后面补上&amp;rdquo;;&amp;quot;）  标识符 命名规则
第一个字符后面可以接 Unicode 字符、&amp;quot;$&amp;quot;符号、&amp;quot;_&amp;ldquo;符号和中文，之后的字符除了这些之外，还可以是数字。
注释 多行注释 &amp;ldquo;/**/&amp;rdquo;
单行注释 &amp;ldquo;//&amp;rdquo;
好的注释：
/踩坑注解/
/为什么代码写的这么奇怪，遇到了什么 bug/
条件语句 if&amp;hellip;else&amp;hellip; /************************/ if(表达式){ 语句1 }eles{ 语句2 } /************************/ if(表达式){ 语句1 }eles if{ 语句2 }else{ 语句3 } /************************/ function fn(){ if(){ return 表达式 } if(){ return 表达式 } return 表达式 } /************************/ 注意</description>
    </item>
    
    <item>
      <title>JavaScript的个人简历</title>
      <link>https://chow1027.xyz/2019/javascript%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</link>
      <pubDate>Wed, 13 Nov 2019 21:30:08 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/javascript%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</guid>
      <description>Javascript：我怎么来的？ JavaScript 诞生于网景公司（Mosaic Communications）。
网景公司希望它们的浏览器能与使用者互动，要达成这一目的，他们需要一种网页脚本语言。
用什么语言来达成这一目的？要么，用当时现有的语言：python、perl、Scheme 等；要么，开发一门新的语言。当时的网景公司分成了两派。
而同年发生了一件大事，Sun 公司将 Oak 语言改名为 Java，正式向市场推出，&amp;ldquo;一次编写，到处运行&amp;quot;的宣传语，使得 Java 很有可能成为未来的主宰。
网景公司看到了机会，决定与 Sun 公司结成联盟。它不仅允许 Java 程序以 applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将 Java 作为脚本语言嵌入网页，只是因为这样会使 HTML 网页过于复杂，后来才不得不放弃。
总之，当时的形势就是，网景公司的整个管理层，都是 Java 语言的信徒，Sun 公司完全介入网页脚本语言的决策。因此，Javascript 后来就是网景和 Sun 两家公司一起携手推向市场的，这种语言被命名为&amp;quot;Java+script&amp;quot;并不是偶然的。
决定开发一种看上去与 Java 足够相似，但是比 Java 简单，使得非专业的网页作者也能很快上手的语言。为了使&amp;quot;开发新语言&amp;quot;这个提案站稳脚跟，这一种语言必须尽快出现，布兰登当时被指定为这门语言的设计师。
布兰登的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将 Scheme 语言作为网页脚本语言的可能性。
而且，布兰登看不起 Java。
1995 年 5 月，布兰登仅花了 10 天时间就把这个拙劣的语言原型设计出来了。最初命名为 Mocha，1995 年 9 月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年 12 月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript。
 布兰登的设计思路：
（1）借鉴 C 语言的基本语法；</description>
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>https://chow1027.xyz/2019/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Mon, 11 Nov 2019 13:18:15 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E6%B5%85%E6%9E%90url/</guid>
      <description>IP ——Internet Protocol 在说 URL 之前，先了解一下什么是 IP。
IP 是互联网协议（网络协议），他的作用是：
 约定如何定位一台设备（手机、电脑、网络摄像头等..） 约定如何封装数据报文，用以与其他设备交流。
当我们要发文件、图片给互联网上的一台设备，我们就要知道这台设备的 IP 地址。  IP 分为内网 IP 和外网 IP。
内网 IP 由我们的路由器创建，我们的手机、电脑等设备连接到路由器，路由器会给我们的设备分配不同的内网 IP。（内网 IP 的一般格式是 192.168.xxx.xxx，一般路由器会给自己分配一个好记的内网 IP，比如 192.168.1.1）
有了内网 IP。我们的设备之间就可以互相通信了，但要和外界进行交流，我们还需要一个外网 IP。
外网 IP 是互联网服务提供商 LSP（电信、移动等）的路由器给我们的路由器分配的一个 IP。LSP 可以理解是为一家管理一些特殊路由器的公司。
外网 IP 代表了我们在互联网中的地址，但它并固定，如果我们重启路由器，那么可能我们会被重新分配一个外网 IP。
比方说当我们要登陆 QQ 邮箱时：
我们的登录信息先是经过了我们自家的路由器，然后经过调制解调器，然后到达 LSP，LSP 可能会连接到其他 LSP 路由器，我们的信息会到达 QQ 邮箱所使用的 LSP 路由器，最终再次通过调制解调器和路由器到达 QQ 邮箱的服务器。
 什么是调制解调器？
我们建立网络是为了我们自己的目的。所以不同的人会建立不同的网络：你的朋友，你的邻居，每个人都可以拥有自己的计算机网络。在你的房子和世界其它地方之间架设电缆将这些不同的网络连接起来是不可能的，那么你该如何处理这件事呢？其实已经有电缆连接到你的房子了，比如，电线和电话。电话基础设施已经可以把你家连接到世界的任何角落，所以它就是我们需要的线。为了连接电话这种网络我们需要一种基础设备叫做调制解调器（modem），调制解调器可以把网络信息变成电话设施可以处理的信息，反之亦然。
 资料来源：MDN:互联网是如何工作的？
如何查看 IP？
通过 ipconfig 命令/通过 ip138.com 查询/ping 命令（下面说）</description>
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>https://chow1027.xyz/2019/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 10 Nov 2019 09:50:38 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>css动画 浏览器渲染原理  根据HTML构建HTML树（DOM） 根据CSS构建CSS树（CSSOM） 将两棵树合并成一棵渲染树（render tree） Layout布局(文档流、盒模型、计算元素的大小和位置) Paint绘制（边框颜色、字体颜色等&amp;hellip;） Composite合成（根据层叠关系展示画面）  三种更新方式 在实际操作中我们一般采用JS更新样式
div.style.background =&amp;#34;red&amp;#34; div.style.display = &amp;#34;none&amp;#34; div.classList.add(&amp;#39;xxx&amp;#39;) --直接给元素添加一个&amp;#34;xxx&amp;#34;的类更好，该元素会拥有该类的所有属性 div.remove() --直接删掉节点  JS/CSS &amp;gt; 样式 &amp;gt; 布局 &amp;gt; 绘制 &amp;gt; 合成 (比如div.remove()，导致文档流的其他元素重新布局。) JS/CSS &amp;gt; 样式 &amp;gt; 绘制 &amp;gt; 合成 (比如更改背景色，则布局不需要改变) JS/CSS &amp;gt; 样式 &amp;gt; 合成 (比如只改了transform)  查询哪个属性触发哪个流程： CSS Triggers
css动画的两种做法  利用transition+transform+hover animation  transform transform的四个常用功能：
 位移translate 缩放scale 旋转rotate 倾斜skew
注意：inline元素不支持transform，要先变成block.  transition transition:属性名 时长 过渡方式 延迟；</description>
    </item>
    
    <item>
      <title>CSS布局</title>
      <link>https://chow1027.xyz/2019/css%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 08 Nov 2019 06:36:14 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E5%B8%83%E5%B1%80/</guid>
      <description>float布局、flex布局、grid布局。
布局分类 固定宽度布局：主要有960/1000/1024px;
不固定宽度布局：靠文档流原理布局。(主要用于手机页面);
响应式布局(混合布局)：既适应pc上的固定布局，也适应手机上的不固定布局。
布局思路 float布局 步骤
 给子元素加上float:left | right; 给父元素加上.clearfix  经验
 一般会预留一些空间或者最后一个元素width不写死。 不需要做响应式，因为手机页面没有IE，而float布局是专门为IE设计的。 IE6/7存在双倍margin的bug，解决办法是  针对IE6/7对margin减半 再加一个display:inline-block;   用&amp;quot;outline&amp;quot;代替&amp;quot;border&amp;rdquo;,可以使得边框不占据内部的空间(outline不在border-box的width计算范围内)  .float { float:left; margin-left:10px; /*一般浏览器会执行这一句,忽略下一句。*/ _margin-left:5px; /*IE6/7认得这一句，因此会先执行上一句，然后执行这一句重设margin，注意下划线_*/ } 代码示例
&amp;lt;!--html--&amp;gt; &amp;lt;header class = &amp;#34;clearfix&amp;#34;&amp;gt; &amp;lt;div class= &amp;#34;float&amp;#34;&amp;gt;balabala&amp;lt;/div&amp;gt; &amp;lt;/header&amp;gt; /*css*/ .clearfix:after { /*&amp;#34;:&amp;#34;或&amp;#34;::&amp;#34;都行，但IE8及以下只认得&amp;#34;:&amp;#34;*/ content:&amp;#34;&amp;#34;; display:block; clear:both; } /*小技巧：如果发现图片下面有多余的东西，可以用这句话让图片居中。*/ vertical-align:top |middle; /*让块级元素居中*/ margin:0 auto; /*下面这句更好，因为没有覆盖元素本身的上下外边距*/ margin-left:auto; margin-right:auto; flex布局 container&amp;ndash;容器(父元素) item&amp;ndash;项目(容器内的子块；子元素)
class = &amp;ldquo;container&amp;rdquo; 样式
/*设置flex布局*/ .container { display:flex | inline-flex; } /*item流动方向-主轴*/ .</description>
    </item>
    
    <item>
      <title>CSS基础</title>
      <link>https://chow1027.xyz/2019/css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 05 Nov 2019 20:03:57 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E5%9F%BA%E7%A1%80/</guid>
      <description>CSS &amp;ndash;层叠样式表 CSS(Cascading Style Sheets)是层叠样式表，所谓层叠有三层含义：
 样式层叠：可多次对同一选择器进行声明。 选择层叠：可用不同选择器对同一元素进行声明。 文件层叠：可用多个文件层叠。  CSS2.1 是 IE 支持的现在使用最广泛的版本，CSS3 是现代版本，分模块进行升级，目前 IE8 只是部分支持。由于 CSS 版本众多，因此要确认我们所使用的 CSS 特性在某个浏览器是否支持，我们可以查询 caniuse 网站。网页地址
CSS 语法 CSS 语法主要有两种：
/*第一种*/ 选择器 { 属性名:属性值; /*注释*/ } 注：
 要使用英文符号； 要区分大小写； 没有&amp;rdquo;//&amp;ldquo;注释； 最后的&amp;rdquo;;&amp;ldquo;虽然可以省略，但不要省略； 浏览器会忽略错误，但不会报错。  /*第二种*/ /*声明字符编码*/ @charset = &amp;#34;UTF-8&amp;#34;; /*导入CSS文件*/ @import url(2.css); /*媒体查询*/ @media(min-width:100px)and(max-width:200px){ 语法一 } 注:
 charset 必须放在第一行。 前两个的@语法必须加&amp;rdquo;;&amp;quot;。 charset 是字符集的意思，但语句本身声明的是字符编码。  CSS 查资料  Google 搜索:MDN + 技术名词； Google 搜索:CSS tricks + 技术名词； Google 搜索:张鑫旭 + 技术名词；   最权威资料：Google 搜索:CSS spec(可以查看 css2.</description>
    </item>
    
    <item>
      <title>CSS盒模型</title>
      <link>https://chow1027.xyz/2019/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 05 Nov 2019 19:49:48 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</guid>
      <description>什么是css盒模型？ 根据css 2.1 中文版文档的描述:
CSS盒模型描述了一个为文档树中的元素生成的并根据视觉格式化模型进行布局的矩形框。
我们可以理解为css中每一个元素都是一个盒子，拥有四个区域，分别是：内容区(content)、内边距(padding)、边框(border)和外边距(margin)。 css盒模型分两种：border-box 和 content-box。
他们的区别在于content-box的宽度只包含content内容区，border-box的宽度包含到border，它包括content内容区、padding内边距、border边框。
返回CSS基础</description>
    </item>
    
    <item>
      <title>HTML实践</title>
      <link>https://chow1027.xyz/2019/html%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 03 Nov 2019 13:42:58 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%AE%9E%E8%B7%B5/</guid>
      <description>选题 &amp;ndash;我最喜欢的动漫《某科学的超电磁炮》 以动漫《某科学的超电磁炮》为主题制作一个简易介绍网页，html 裸奔。
收集内容 资料来源：
维基百科
萌娘百科
ToC &amp;ndash;Table of Content 为网页添加页内导航（锚点）
实现手段：为每一个标题添加 id，通过 a 标签的 href 指向这个 id。
&amp;lt;nav&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;#introduce&amp;#34;&amp;gt;作品介绍&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;h2 id=&amp;#34;introduce&amp;#34;&amp;gt;作品介绍&amp;lt;/h2&amp;gt; 添加外部资源 添加图片，注意：
  设置图片大小统一，不要让图片变形
width/height 二选一设置相同的值。
  图片比例不对的要进行裁剪
  图片体积过大要进行压缩，一般不超过 300kb
  添加图片预览
通过 a 标签超链接到原图，target 设置为&amp;rdquo;_blank&amp;rdquo;。
  兼容手机  meta:vp  &amp;lt;!--meta:vp--&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&amp;#34; /&amp;gt;  设置图片最大宽度为 100%  img { max-width: 100%; } 手机调试   通过 chrome 控制台</description>
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>https://chow1027.xyz/2019/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 01 Nov 2019 21:04:35 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      <description>a 标签 &amp;lt;!-- html --&amp;gt; &amp;lt;a href=&amp;#34;//google.com&amp;#34; target=&amp;#34;_blank&amp;#34; download rel=&amp;#34;noopener&amp;#34;&amp;gt; &amp;lt;/a&amp;gt; 作用 跳转到外部页面
跳转到内部锚点
跳转到电话/邮箱
属性 href
href 属性指定 a 标签要跳转到的新页面，他的取值可以是:
网址 https://google.com http://google.com //google.com  可以是 https 也可以是 http，当采用无协议传输方式时，浏览器会自动采取 http 或 https。
路径 a/b/c /a/b/c  当 href 指向某个路径时，a 标签实际访问的是 http 服务的根目录&amp;rdquo;/&amp;quot;（也就是这个网站相关文件的根目录）。
用&amp;rdquo;/&amp;ldquo;开头的即表示根目录，此时用的是绝对路径。
&amp;ldquo;./&amp;ldquo;的意思是在当前 html 所在的目录中找，这是一种相对路径。
伪协议 javascript:代码; mailto:邮箱 tel:手机号  javascript:代码; 是 JS 的伪协议写法，用户点击 a 标签就执行该 JS 代码。
ID&amp;ldquo;#xxx&amp;rdquo;
href 可以指向某个 ID，用户点击 a 标签页面就会跳转到该拥有该 ID 的标签所在的位置。
target
target 属性指定 a 标签的新页面在浏览器中的打开位置，他的取值有:</description>
    </item>
    
    <item>
      <title>HTML入门笔记</title>
      <link>https://chow1027.xyz/2019/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 31 Oct 2019 18:16:17 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>什么是 HTML?它是谁发明的? 答：HTML 是超文本标记语言（Hypertext Markup Language）,在 1990 年由李爵士（Tim Berners-Lee）发明。
HTML 起手式 起手式唯一招式：&amp;quot;!+tab&amp;rdquo;
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 注：
 !要用英文输入法。 lang=&amp;quot;en&amp;quot;,language 为英文，建议改成&amp;quot;zh-CN&amp;rdquo;。 charset=&amp;quot;UTF-8&amp;quot;，支持各国字符的编码，不要改！ &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;防止页面缩放，适应手机屏幕。 &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;告诉浏览器采用最新的 ie 内核解析本页面。  HTML 章节标签 HTML 章节标签包括：
 h1 ~ h6,表示标题 1 ~ 标题 6 section,表示章节 article,表示文章 p,表示段落 header,表示页面的页眉（一般是页面的标题） main,表示页面的主要内容（页面主体部分） footer,表示页面的页脚（一般是版权声明、作者等） aside,表示旁支内容（与页面主体无关的部分,比如导航 条等） div,用于划分内容块  HTML 全局属性 全局属性是所有标签都有的属性。</description>
    </item>
    
  </channel>
</rss>