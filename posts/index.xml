<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 呆尬猴的博客</title>
    <link>https://chow1027.xyz/posts/</link>
    <description>Recent content in Posts on 呆尬猴的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 14 Dec 2019 19:08:42 +0800</lastBuildDate>
    
	<atom:link href="https://chow1027.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MVC:拒绝面条式代码</title>
      <link>https://chow1027.xyz/2019/mvc/</link>
      <pubDate>Sat, 14 Dec 2019 19:08:42 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/mvc/</guid>
      <description>设计模式概述 设计模式是我们在进行程序设计的过程中，对普遍存在的问题（或反复出现的情况）提出的一种统一的解决方案。 比如适配器模式、Promise、重载、别名、getter/setter、观察者模式等。
代码模块化 如果代码中存在一些可以具体实现某些功能的代码块，而这些代码块的功能在其他的地方也可以适用。那么我们可以将这部分代码可以封装成一个函数、一个类，这就是代码的模块化；
根据操作对象的不同，比如将专门操作DOM对象的代码放在一类，将专门负责页面渲染更新的代码当在一类，这也是代码的模块化。
就是说，总是会有&amp;rdquo;万金油&amp;rdquo;的代码，是所有项目或块的通用代码，我们将这些具有相同&amp;rdquo;目的&amp;rdquo;的代码整合成一个模块，就可以使代码的整体结构更加清晰；模块之间虽然有联系，但每个模块只需关注自身的执行情况以及传进来的参数即可，不会牵一发而动全身，这也是一种解耦的思想。
MVC 设计模式 MVC 是设计模式的一种，是我们优化代码结构的一种方案。同时，他也是代码模块化的一种体现。
它不直接指导具体代码的实现，而是从全局的、宏观的角度，指导各个部分的代码应该怎么“摆”，从而使代码整体结构更加规律、直观。 当需求越是复杂，要实现的功能越复杂的时候，MVC 所带来的好处就越明显。
MVC 把代码的结构分成三个部分：Model-数据、View-视图、Control-控制器。
Model 数据 Model 负责代码中的所有与数据相关的部分，比如数据的更新、数据的读取、数据的存储等。 它不依赖于 View 和 Control，也就是说，它并不关心数据会被如何显示，或是被如何处理，它只需要管理好它的数据即可。 以下面的 Model 举例:
class Model{ constructor(options){ // 接受数据 const keys = [&#39;data&#39;,&#39;update&#39;,&#39;create&#39;,&#39;delete&#39;,&#39;get&#39;] keys.forEach((key)=&amp;gt;{ if(key in options){ this[key]=options[key] } }) } // 各种数据相关的方法 create(){} delete(){} update(){} get(){} }  View 视图 View 负责处理用户界面相关的代码，比如页面的重新渲染。 同样，View 并不关心它渲染的内容，它只要做好它的工作就可以了。 以下面的 代码 举例:
const view = { init(){} // 页面初始化 template:`&amp;lt;section&amp;gt;&amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt;&amp;lt;/section&amp;gt;` // 页面要渲染的内容 render(){} // 渲染函数 }  Controller 控制器 Controller负责统筹整个程序的运作，类似中央处理器。 比如对Model的数据进行处理，将处理后的数据通知给 View 更新；处理 View 传达的事件，更新数据后传达给 Model。 以下面的 Controller 举例:</description>
    </item>
    
    <item>
      <title>Axios使用手册</title>
      <link>https://chow1027.xyz/2019/axios%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</link>
      <pubDate>Tue, 03 Dec 2019 18:45:06 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/axios%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</guid>
      <description>参考文献：
axios中文网
axios英文原文
GET 请求 /*为给定 ID 的 User 创建请求*/ axios.get(&#39;/user?ID = 12345&#39;) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); }) /*可以通过对象传递 User 的 ID*/ axios.get(&#39;/user&#39;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); })  POST 请求 /*执行post请求*/ axios.post(&#39;user&#39;,{ firstName:&#39;Fred&#39;, lastName:&#39;Flintstone&#39; }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error); })  执行多个并发请求 function getUserAccount(){ return axios.get(&#39;/user/12345&#39;); } function getUserPermissions(){ return axios.get(&#39;/user/12345/permissions&#39;); } axios.all([getUserAccount(),getUserPermissions()]) .then(axios.spread(function(acct,perms){ // 两个请求现在都执行完成 }));  创建请求 /*发送POST请求*/ axios({ method:&#39;post&#39;, url:&#39;/user/12345&#39;, data:{ firstName:&#39;Fred&#39;, lastName:&#39;Flintstone&#39; } }); /*获取远端照片*/ axios({ method:&#39;get&#39;, url:&#39;http://bit.</description>
    </item>
    
    <item>
      <title>JQuery中的函数</title>
      <link>https://chow1027.xyz/2019/jquery%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 30 Nov 2019 18:52:19 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/jquery%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>版权声明：本文为周啟尧原创文章，著作权归本人和饥人谷所有，转载务必注明来源
&amp;mdash;参考资料来源：
jQuery设计思想&amp;mdash;阮一峰
jQuery中文文档
jQuery(选择器)用于获取对应的元素，但是它不返回对应的元素，
他返回一个对象，这个对象可以操作对应的元素。
jQuery获取页面元素 利用构造函数jQuery()（或者它的别称$），传入一个css选择器作为参数。
/*选取整个文档对象*/ $(document) /*选取id为xxx的网页元素*/ $(&#39;#xxx&#39;) /*选取class为xxxx的div元素*/ $(&#39;div.xxxx&#39;) /*选取name属性为first的input元素*/ $(&#39;input[name=first]&#39;)  也可以传入jQuery特有的选择器
/*选择网页第一个a元素*/ $(&#39;a:first&#39;) /*选择表格的奇数行*/ $(&#39;tr:odd&#39;) /*选择表单中的input元素*/ $(&#39;#myForm :input&#39;) /*选择可见的div元素*/ $(&#39;div:visible&#39;) /*选择所有的div元素，除了前三个*/ $(&#39;div:gt(2)&#39;) /*选择处于动画状态的div元素*/ $(&#39;div:animated&#39;)  链式操作 jQuery中的链式操作是通过jQuery对象调用jQuery函数，再次返回经过函数处理的jQuery对象实现的。
比如：
$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);  $(&#39;div&#39;)返回一个对象，对象可以操作页面中的所有div；
.find(&#39;h3&#39;)返回一个对象,对象操作上述div对象中的所有h3元素；
.eq(2)返回一个对象，对象只操作上述h3元素的第三个；
.html(&#39;Hello&#39;)返回一个对象，该对象是将上述h3元素的内容更改为hello后的结果。
可以通过.end()回退一步。
可以通过链式操作对jQuery选择的元素进行更进一步的精确选择
// 选择包含p元素的div元素 $(&#39;div&#39;).has(&#39;p&#39;); // 选择class不等于myclass的div元素 $(&#39;div&#39;).not(&#39;.myclass&#39;); // 选择class等于myclass的div元素 $(&#39;div&#39;).filter(&#39;.myclass&#39;); // 选择第一个div元素 $(&#39;div&#39;).first(); // 选择第六个div元素 $(&#39;div&#39;).eq(5); // 选择div元素后面的第一个p元素 $(&#39;div&#39;).next(&#39;p&#39;) // 选择div元素的父元素 $(&#39;div&#39;).parent() // 选择离div最近的form父元素 $(&#39;div&#39;).closest(&#39;form&#39;) // 选择div所有子元素 $(&#39;div&#39;).</description>
    </item>
    
    <item>
      <title>For In与for Of</title>
      <link>https://chow1027.xyz/2019/for-in%E4%B8%8Efor-of/</link>
      <pubDate>Wed, 27 Nov 2019 06:52:50 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/for-in%E4%B8%8Efor-of/</guid>
      <description>版权声明：本文为周啟尧原创文章，著作权归本人所有，转载务必注明来源
参考文章
(for&amp;hellip;in&amp;hellip;与for&amp;hellip;of&amp;hellip;区别)[https://juejin.im/post/5b567b5a5188251ac0630bda]
for in更适合用来遍历对象，不要使用for in 遍历数组。
使用for in 遍历数组会产生以下问题：
1. JavaScript中的数组是用对象模拟出来的，数组的索引值也就是对象中的key，是字符串类型的数字。不能直接进行几何运算。
2. 使用for in遍历数组会遍历数组所有可枚举属性，包括原型。
3. 遍历的顺序可能不是按照数组实际的内部顺序。
for of 只是遍历数组中的元素，不包括数组的原型属性和索引。
for of遍历的是数组中的元素值，for in遍历的是索引。</description>
    </item>
    
    <item>
      <title>Let和const在for循环中的运用</title>
      <link>https://chow1027.xyz/2019/let%E5%92%8Cconst%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</link>
      <pubDate>Wed, 27 Nov 2019 06:12:07 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/let%E5%92%8Cconst%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</guid>
      <description>版权声明：本文为周啟尧原创文章，著作权归本人所有，转载务必注明来源
参考资料来源：
(let const缓存for循环的中间变量)[https://juejin.im/post/5c6bb8566fb9a049f154c363]
(let 和 const 在for 循环中的使用)[https://www.cnblogs.com/SamWeb/p/10659352.html]
问题的根源起源于手写jQuery的过程中用到的代码：
find(selector) { let array = [] for (let i = 0; i &amp;lt; elements.length; i++) { const elements2 = Array.from(elements[i].querySelectorAll(selector)) array = array.concat(elements2) } array.oldApi = this return jQuery(array) }  const关键字定义的变量不能被重新赋值，那它为什么可以出现在for循环中？
let 当我们在for循环中使用let时，每一次的迭代都会重新声明一次变量。比如for(let i = 0; i &amp;lt; 10; i++)
i变量被声明了10次，每一次赋的值为上一次迭代完成时的值，这样的话，循环体内获取到的i，每次也都是全新的变量i，而不是像使用var声明时得到的是全局变量，并且每一次迭代完成后，i变量就消失了。
除了常规for循环，for-in和for-of同理。每一次迭代都是重新声明一个新的迭代对象，而不是给原来的迭代对象赋新值。
let arr = [1, 2, 3]; for (let key in arr) { console.log(key) } // 0 1 2 for(let key of arr){ console.</description>
    </item>
    
    <item>
      <title>谈谈浏览器解析html时的阻塞问题</title>
      <link>https://chow1027.xyz/2019/%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90html%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 25 Nov 2019 13:33:43 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90html%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/</guid>
      <description>参考文章：
DOM阻塞总结
深入浅出浏览器渲染原理
浏览器是如何解析html的？
浏览器阻塞
浏览器是如何工作的? 当我们在地址栏输入一个合法的URL后，浏览器首先进行域名解析，得到服务器的IP地址，然后浏览器会给服务器发送GET请求，等到服务器响应200后开始下载并解析html。
页面主要由DOM、CSS、JavaScript等部分构成，其中CSS和JavaScript既能内联也能以脚本的形式引入，此外还有img、iframe等其他资源，所有的这些资源都是通过dom标签的形式嵌入在html页面中，接下来我们分析一下dom的构建过程。
浏览器的工作流程  构建DOM =&amp;gt; 构建CSSOM =&amp;gt; 构建渲染树(Rendering Tree) =&amp;gt; 布局(也叫回流) =&amp;gt; 绘制
 大体来讲：
1. 浏览器会解析三个东西：
* HTML/SVG/XHTML，产生DOM Tree。
* CSS，产生CSS Rule Tree。
* JavaScript，脚本，通过DOM API 和CSSOM API操作DOM和CSSOM。
2. 解析完成后，结合DOM Tree和CSSOM Tree构造Rendering Tree。
* Rendering Tree和DOM Tree并不是完全相等的，比如Header和display：none就不会出现在Rendering Tree中。
* 将CSS Rule添加到Rendering Tree上的节点，然后计算每个元素的位置，这就是布局。
3. 调用操作系统Native GUI的API绘制。
DOM的构建过程 DOM的构建过程是顺序的，渐进式的。从第一行开始，逐行依次解析，并且会将已解析完成的部分显示出来。
如何判定DOM构建完成？
我们使用JavaScript操作DOM或者给DOM绑定事件的前提就是DOM树已经构建完成。当DOM树构建完成时，document对象会派发事件DOMContentLoaded来通知DOM树已经构建完成。
html从第一行开始解析，遇到外联资源(外联CSS、外联JS、image、iframe等)则会请求下载对应的资源。而其中有一部分会影响（阻塞）DOM的构建。
正常情况下CSSOM和DOM的构建是互不干扰的
浏览器下载HTML文件，解析HTML从而构建DOM。
遇到link[rel=stylesheet]时，将其加入下载队列，继续构建DOM。（CSS不会阻塞DOM的构建）
而JS的加载、解析和执行都会阻塞DOM的构建
当HTML解析器遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。
接下来具体分析。
CSSOM和DOM CSSOM和DOM的构建互不干扰，那么所有的CSS都不影响DOM的构建吗？
不是，这是有前提的。
前提是这些CSS样式不被JavaScript需要。
我们知道，JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。而不完整的CSSOM是无法使用的，因此如果JavaScript想访问CSSOM并更改它，必须要拿到完整的CSSOM，而JavaScript的加载、解析和执行都会阻塞DOM的构建，这样一来就导致了：</description>
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>https://chow1027.xyz/2019/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Mon, 18 Nov 2019 15:18:59 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      <description>版权声明：本文为周啟尧原创文章，著作权归本人和饥人谷所有，转载务必注明来源
&amp;mdash;以下文档部分转载自知乎文章《从一道面试题-计时器函数谈闭包》，作者：胡桃夹子
文章地址：https://zhuanlan.zhihu.com/p/80117819
/*********************/ let i = 0 for(i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) } /*********************/  上述代码会打印出6个6。
为什么不是0、1、2、3、4、5？
原因是
setTimeout是一个计时器，设置时间为0秒。（计时0秒，相当于是马上要执行）
setTimeout是从队列结束的时候开始计时的，如果前面的进程没有结束，那么要等到前面的进程结束后才开始计时。在这里的任务队列就是它自己所在的循环。
意思是，执行完当前的代码之后立即执行计时器中的代码。而上面的&amp;rdquo;当前代码&amp;rdquo;就是指for循环。
在for循环执行完毕后，此时的i值等于6，才轮到setTimeout异步执行箭头函数。
6个setTimeout打印出当前的i值，执行结果就是打印6个6。
为了更好的理解，这里可以想象一个小场景。
 for循环想让setTimeout打印点东西，他说：boss给了我个任务，这个i是我第一次执行的结果，你打印给boss看看呗。(此时i=0)
setTimeout说：好的。然后他在便利贴上写道：打印i给老板看，放在了一边。（这里的i没有写明具体值）
for循环执行完第二遍又来根setTimeout说：这个i是我第二次执行的结果，你打印给boss看看呗。(此时i=1)
setTimeout又说：好的。然后他又在便利贴上写道：打印i给老板看，放在了第一张便利贴的下面。（这里的i没有写明具体值）
同样的情形发生了六次，在第六次的时候，for循环说：这个i是我的最终成果了，你打印一下。（i=6）
for循环的工作结束了，想起之前for循环安排的工作都没干，于是它找回之前的便利贴，一张一张执行。
每一张都写着&amp;rdquo;打印i&amp;rdquo;,于是setTimeout直接把i打印了6遍给boss。
 怎样才能让上述代码打印出0、1、2、3、4、5？
 利用闭包，用函数参数来保存i的值。
let i = 0 for(i = 0; i&amp;lt;6; i++){ !function(i){ setTimeout(()=&amp;gt;{ console.log(i) },0) }(i) }   上述代码中，for循环每一次循环，都会把i的值作为参数传给循环内的立即执行函数，再由立即执行函数把i的值传给setTimeout执行。
setTimeout与立即执行函数构成了闭包。
setTimeout每一次得到的参数来自立即执行函数。而立即执行函数每一次接受的i值不同，因此传给setTimeout的i值不同。
同样也是6个setTimeout，但setTimeout打印的i值来自立即执行函数，因此打印出0、1、2、3、4、5。
 对应上面的小场景。
这里相当于是在for循环和setTimeout之间安插了一位记录员function。
for循环每一次执行的版本（i的具体值）都会给function记录下来。
当setTimeout要执行的时候，会从function（而不是for循环）手中得到i的值。
 上面的代码还可以写成：
/*****************************/ let i = 0 for(i = 0; i&amp;lt;6; i++){ setTimeout(!</description>
    </item>
    
    <item>
      <title>JS对象</title>
      <link>https://chow1027.xyz/2019/js%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 16 Nov 2019 14:41:49 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%AF%B9%E8%B1%A1/</guid>
      <description>JavaScript的其中数据类型：四基两空一对象，今天我们来聊一聊对象Object，
以及原型是什么？
唯一的复杂类型——Object //常用写法： let obj = {&#39;name&#39;:&#39;xxx&#39;,&#39;age&#39;:&#39;xxx&#39;,} //正规写法 let obj = new Object({&#39;name&#39;:&#39;xxx&#39;,&#39;age&#39;:&#39;xxx&#39;}) //匿名对象 console.log({&#39;name&#39;:&#39;xxx&#39;,&#39;age&#39;:&#39;xxx&#39;})  注意：
1. 键名是字符串，可以包含任何字符；
2. &amp;ldquo;可以省略，但是省略后只能写标识符和数字；（所以为什么要省略它呢？写上！）
3. 对象没有所谓的数字下标，要得到对象中的某个值，只能通过它的键名获取。
4. 对象中的键值对又称为这个对象的属性。
let obj={ 1e2:&#39;一百&#39; } /*******结果是********/ obj = {&#39;100&#39;:&#39;一百&#39;}  如果对象的键是一个表达式，那么JavaScript会将该表达式求值，并将结果转换为字符串。
提问：字符串是一个常量，我能不能用变量的值作为Object的键呢？ 答案是肯定的。
怎么做？
用&amp;rsquo;[]&amp;lsquo;将变量名包裹起来
let a = &#39;xxx&#39; var obj = { [a] = &#39;hello&#39; } /*******结果是********/ obj = {&#39;xxx&#39;:&#39;hello&#39;}  同上面表达式的原理类似，JavaScript会先得到变量的值，再转为字符串。
Object中的增删查改 删除属性 delete obj.xxx 或 delete obj[&amp;lsquo;xxx&amp;rsquo;] ——删除obj对象的xxx属性
注意区分属性值为 undefined 和 不含属性名</description>
    </item>
    
    <item>
      <title>JS基本语法</title>
      <link>https://chow1027.xyz/2019/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 15 Nov 2019 06:40:40 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>表达式和语句 表达式和语句的 一般 区别  表达式一般有值，语句可能有或没有；
 语句一般会改变环境（声明、赋值等）
 上述区别并不绝对。
  关于值和返回值
只有函数（表达式）才有返回值的概念。比如：
 1+2的值是3；
 add(1,2）表达式的值为函数的返回值
 console.log表达式的值为函数本身
 console.log(3)表达式的值为undefined（console.log没有返回值，打印出&amp;rdquo;3&amp;rdquo;是它的功能）
  注意事项  JavaScript中区分大小写；
 大部分空格没有意义；
 大部分回车没有意义（除了return，return后面不能随便回车，否则JavaScript会自动在return后面补上&amp;rdquo;;&amp;ldquo;）  标识符 命名规则
第一个字符后面可以接Unicode字符、&amp;rdquo;$&amp;ldquo;符号、&amp;rdquo;_&amp;ldquo;符号和中文，之后的字符除了这些之外，还可以是数字。
注释 多行注释 &amp;ldquo;/**/&amp;rdquo;
单行注释 &amp;ldquo;//&amp;rdquo;
好的注释：
/踩坑注解/
/为什么代码写的这么奇怪，遇到了什么bug/
条件语句 if&amp;hellip;else&amp;hellip; /************************/ if(表达式){ 语句1 }eles{ 语句2 } /************************/ if(表达式){ 语句1 }eles if{ 语句2 }else{ 语句3 } /************************/ function fn(){ if(){ return 表达式 } if(){ return 表达式 } return 表达式 } /************************/  注意</description>
    </item>
    
    <item>
      <title>JavaScript的个人简历</title>
      <link>https://chow1027.xyz/2019/javascript%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</link>
      <pubDate>Wed, 13 Nov 2019 21:30:08 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/javascript%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</guid>
      <description>Javascript：我怎么来的？ JavaScript诞生于网景公司（_Mosaic Communications_）。
网景公司希望它们的浏览器能与使用者互动，要达成这一目的，他们需要一种网页脚本语言。
用什么语言来达成这一目的？要么，用当时现有的语言：python、perl、Scheme等；要么，开发一门新的语言。当时的网景公司分成了两派。
而同年发生了一件大事，Sun公司将Oak语言改名为Java，正式向市场推出，&amp;rdquo;一次编写，到处运行&amp;rdquo;的宣传语，使得Java很有可能成为未来的主宰。
网景公司看到了机会，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。
总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为&amp;rdquo;Java+script&amp;rdquo;并不是偶然的。
决定开发一种看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手的语言。为了使&amp;rdquo;开发新语言&amp;rdquo;这个提案站稳脚跟，这一种语言必须尽快出现，布兰登当时被指定为这门语言的设计师。
布兰登的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性。
而且，布兰登看不起Java。
1995年5月，布兰登仅花了10天时间就把这个拙劣的语言原型设计出来了。最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中部署时被重命名为JavaScript。
 布兰登的设计思路：
（1）借鉴C语言的基本语法；
（2）借鉴Java语言的数据类型和内存管理；
（3）借鉴Scheme语言，将函数提升到&amp;rdquo;第一等公民&amp;rdquo;（first class）的地位；
（4）借鉴Self语言，使用基于原型（prototype）的继承机制。
 Javascript语言实际上是两种语言风格的混合产物&amp;mdash;-（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。
Javascript：我来到这个世界之后 JavaScript在浏览器推出后大受欢迎，微软为了与之对抗，开发了Jscript。Jscript可以认为是微软开发的JavaScript的翻版。两个版本在浏览器端共存意味着语言标准化的缺失。
网景公司为了取得先机，1996年11月率先向ECMA提交语言标准，1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。
Javascript：我为什么这么糟 从JavaScript上面的经历来看，我们不难找出原因。
 设计阶段过于仓促
  JavaScript的设计师仅仅用了10天就设计出JavaScript，而且设计师只是为了交差，本人并不愿意这样设计。
其次JavaScript设计的初衷是为了实现一些简单的页面交互，并没有考虑复杂应用的需要。
 没有先例  JavaScript同时结合了函数式编程和面向对象编程的特点，史无前例，直到现在为止，JavaScript仍然是世界上唯一使用prototype继承模型的语言，它并没有设计先例可以参考。
 过早的标准化  JavaScript发展迅速，没有时间优化设计。
1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。Javascript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。
更糟的是，Javascript的规格还没来及调整，就固化了。
1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请Javascript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。
也就是说，Javascript推出一年半之后，国际标准就问世了。设计缺陷还没有充分暴露就成了标准。相比之下，C语言问世将近20年之后，国际标准才颁布。
Javascript：我糟在哪？  不适合开发大型程序
 Javascript没有名称空间（namespace），很难模块化； 没有如何将代码分布在多个文件的规范； 允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。  非常小的标准库
  Javascript提供的标准函数库非常小，只能完成一些基本操作，很多功能都不具备。
 null和undefined  null属于对象（object）的一种，意思是该对象为空；undefined则是一种数据类型，表示未定义。
 全局变量难以控制  Javascript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。</description>
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>https://chow1027.xyz/2019/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Mon, 11 Nov 2019 13:18:15 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E6%B5%85%E6%9E%90url/</guid>
      <description>IP ——Internet Protocol 在说URL之前，先了解一下什么是IP。
IP是互联网协议（网络协议），他的作用是：
1. 约定如何定位一台设备（手机、电脑、网络摄像头等..）
2. 约定如何封装数据报文，用以与其他设备交流。
当我们要发文件、图片给互联网上的一台设备，我们就要知道这台设备的IP地址。
IP分为内网IP和外网IP。
内网IP由我们的路由器创建，我们的手机、电脑等设备连接到路由器，路由器会给我们的设备分配不同的内网IP。（内网IP的一般格式是192.168.xxx.xxx，一般路由器会给自己分配一个好记的内网IP，比如192.168.1.1）
有了内网IP。我们的设备之间就可以互相通信了，但要和外界进行交流，我们还需要一个外网IP。
外网IP是互联网服务提供商LSP（电信、移动等）的路由器给我们的路由器分配的一个IP。LSP可以理解是为一家管理一些特殊路由器的公司。
外网IP代表了我们在互联网中的地址，但它并固定，如果我们重启路由器，那么可能我们会被重新分配一个外网IP。
比方说当我们要登陆QQ邮箱时：
我们的登录信息先是经过了我们自家的路由器，然后经过调制解调器，然后到达LSP，LSP可能会连接到其他LSP路由器，我们的信息会到达QQ邮箱所使用的LSP路由器，最终再次通过调制解调器和路由器到达QQ邮箱的服务器。
 什么是调制解调器？
我们建立网络是为了我们自己的目的。所以不同的人会建立不同的网络：你的朋友，你的邻居，每个人都可以拥有自己的计算机网络。在你的房子和世界其它地方之间架设电缆将这些不同的网络连接起来是不可能的，那么你该如何处理这件事呢？其实已经有电缆连接到你的房子了，比如，电线和电话。电话基础设施已经可以把你家连接到世界的任何角落，所以它就是我们需要的线。为了连接电话这种网络我们需要一种基础设备叫做调制解调器（modem），调制解调器可以把网络信息变成电话设施可以处理的信息，反之亦然。
 资料来源：MDN:互联网是如何工作的？
如何查看IP？
通过ipconfig命令/通过ip138.com查询/ping命令（下面说）
端口号 有了IP，我们现在可以定位到互联网上的服务器。
但是还不够，我们还需要端口号。
因为一台设备可以提供很多服务，每个服务都对应一个号码，这个号码就是端口号。
 要提供HTTP服务最好使用80端口；
 要提供HTTPS服务最好使用443端口；
 要提供FTP服务最好使用21端口 一台机器可以有65535个端口  怎么知道什么时候该用什么端口？
维基百科搜索&amp;rdquo;TCP 端口&amp;rdquo;。快捷入口
注意端口的使用规则：
1. 0-1023号端口是留给系统使用的。
2. 只有拥有管理员权限才能使用这1024个端口。
3. 其他端口可以给普通用户使用。（比如http-server用的8080端口）
4. 一个端口被占用了，就只能用别的端口。
DNS ——Domain Name System 通过IP地址，我们就可以访问QQ邮箱、淘宝、京东，然后就使用里面的服务。
但是没那么简单。
因为IP地址是一串数字，它并不是那么容易记忆，于是人类发明了域名，用以直观的代表这个IP地址。
有了域名，我们现在就可以通过baidu.com访问百度主页，通过taobao.com访问淘宝主页，通过mail.qq.com访问qq邮箱。
我们人类知道了域名所对应的IP地址，那么计算机是怎么知道的呢？
答案是通过DNS。
DNS是域名系统，它类似于一本电话册，里面记录了每一个域名所对应的IP地址，每当我们访问一个域名，浏览器会先到DNS服务器询问这个域名对应的IP地址，然后再跳转到这个IP地址。
 DNS数据库存储在全球每个DNS服务器上，所有这些服务器都源于(refer to)几个被称为“权威名称服务器”或“顶级DNS服务器”。
 域名 我们知道了域名就是IP地址的别称，它们为互联网上任何可用的网页服务器提供了人类可读的地址。
域名有分级（以www.xiedaimala.com为例）
.com是顶级域名；
xiedaimala.com是二级域名（俗称一级域名）
www.xiedaimala.com是三级域名（俗称二级域名）</description>
    </item>
    
    <item>
      <title>css知识总结</title>
      <link>https://chow1027.xyz/2019/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 10 Nov 2019 09:50:38 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>css动画 浏览器渲染原理  根据HTML构建HTML树（DOM） 根据CSS构建CSS树（CSSOM） 将两棵树合并成一棵渲染树（render tree） Layout布局(文档流、盒模型、计算元素的大小和位置) Paint绘制（边框颜色、字体颜色等&amp;hellip;） Composite合成（根据层叠关系展示画面）  三种更新方式 在实际操作中我们一般采用JS更新样式
div.style.background =&amp;quot;red&amp;quot; div.style.display = &amp;quot;none&amp;quot; div.classList.add(&#39;xxx&#39;) --直接给元素添加一个&amp;quot;xxx&amp;quot;的类更好，该元素会拥有该类的所有属性 div.remove() --直接删掉节点   JS/CSS &amp;gt; 样式 &amp;gt; 布局 &amp;gt; 绘制 &amp;gt; 合成 (比如div.remove()，导致文档流的其他元素重新布局。) JS/CSS &amp;gt; 样式 &amp;gt; 绘制 &amp;gt; 合成 (比如更改背景色，则布局不需要改变) JS/CSS &amp;gt; 样式 &amp;gt; 合成 (比如只改了transform)  查询哪个属性触发哪个流程： CSS Triggers
css动画的两种做法  利用transition+transform+hover animation  transform transform的四个常用功能：
1. 位移translate
2. 缩放scale
3. 旋转rotate
4. 倾斜skew
注意：inline元素不支持transform，要先变成block.
transition transition:属性名 时长 过渡方式 延迟；</description>
    </item>
    
    <item>
      <title>css布局</title>
      <link>https://chow1027.xyz/2019/css%E5%B8%83%E5%B1%80/</link>
      <pubDate>Fri, 08 Nov 2019 06:36:14 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E5%B8%83%E5%B1%80/</guid>
      <description>float布局、flex布局、grid布局。
布局分类 固定宽度布局：主要有960/1000/1024px;
不固定宽度布局：靠文档流原理布局。(主要用于手机页面);
响应式布局(混合布局)：既适应pc上的固定布局，也适应手机上的不固定布局。
布局思路 float布局 步骤
1. 给子元素加上float:left | right;
2. 给父元素加上.clearfix
经验
1. 一般会预留一些空间或者最后一个元素width不写死。
2. 不需要做响应式，因为手机页面没有IE，而float布局是专门为IE设计的。
3. IE6/7存在双倍margin的bug，解决办法是
* 针对IE6/7对margin减半
* 再加一个display:inline-block;
4. 用&amp;rdquo;outline&amp;rdquo;代替&amp;rdquo;border&amp;rdquo;,可以使得边框不占据内部的空间(outline不在border-box的width计算范围内)
.float { float:left; margin-left:10px; /*一般浏览器会执行这一句,忽略下一句。*/ _margin-left:5px; /*IE6/7认得这一句，因此会先执行上一句，然后执行这一句重设margin，注意下划线_*/ }  代码示例
&amp;lt;!--html--&amp;gt; &amp;lt;header class = &amp;quot;clearfix&amp;quot;&amp;gt; &amp;lt;div class= &amp;quot;float&amp;quot;&amp;gt;balabala&amp;lt;/div&amp;gt; &amp;lt;/header&amp;gt;  /*css*/ .clearfix:after { /*&amp;quot;:&amp;quot;或&amp;quot;::&amp;quot;都行，但IE8及以下只认得&amp;quot;:&amp;quot;*/ content:&amp;quot;&amp;quot;; display:block; clear:both; }  /*小技巧：如果发现图片下面有多余的东西，可以用这句话让图片居中。*/ vertical-align:top |middle; /*让块级元素居中*/ margin:0 auto; /*下面这句更好，因为没有覆盖元素本身的上下外边距*/ margin-left:auto; margin-right:auto;  flex布局 container&amp;ndash;容器(父元素) item&amp;ndash;项目(容器内的子块；子元素)</description>
    </item>
    
    <item>
      <title>CSS基础</title>
      <link>https://chow1027.xyz/2019/css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 05 Nov 2019 20:03:57 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E5%9F%BA%E7%A1%80/</guid>
      <description>CSS &amp;ndash;层叠样式表 CSS(Cascading Style Sheets)是层叠样式表，所谓层叠有三层含义：
 样式层叠：可多次对同一选择器进行声明。 选择层叠：可用不同选择器对同一元素进行声明。 文件层叠：可用多个文件层叠。  CSS2.1是IE支持的现在使用最广泛的版本，CSS3是现代版本，分模块进行升级，目前IE8只是部分支持。由于CSS版本众多，因此要确认我们所使用的CSS特性在某个浏览器是否支持，我们可以查询caniuse网站。网页地址
CSS语法 CSS语法主要有两种：
/*第一种*/ 选择器 { 属性名:属性值; /*注释*/ }  注：
1. 要使用英文符号； 2. 要区分大小写； 3. 没有&amp;rdquo;//&amp;ldquo;注释； 4. 最后的&amp;rdquo;;&amp;ldquo;虽然可以省略，但不要省略； 5. 浏览器会忽略错误，但不会报错。
/*第二种*/ /*声明字符编码*/ @charset = &amp;quot;UTF-8&amp;quot;; /*导入CSS文件*/ @import url(2.css); /*媒体查询*/ @media(min-width:100px)and(max-width:200px){ 语法一 }  注:
1. charset必须放在第一行。 2. 前两个的@语法必须加&amp;rdquo;;&amp;ldquo;。 3. charset是字符集的意思，但语句本身声明的是字符编码。
CSS查资料  Google搜索:MDN + 技术名词； Google搜索:CSS tricks + 技术名词； Google搜索:张鑫旭 + 技术名词； 最权威资料：Google搜索:CSS spec(可以查看css2.1中文版)  CSS的调试  使用W3C验证器。在线验证器 使用VScode/Webstorm看字体颜色。 使用开发者工具看警告。(有黄色的警告标志证明肯定是语法错误；被划掉说明语法错误或者是样式被覆盖/忽略。) border调试法  border调试法 当怀疑某个元素出现问题：</description>
    </item>
    
    <item>
      <title>CSS盒模型</title>
      <link>https://chow1027.xyz/2019/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 05 Nov 2019 19:49:48 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</guid>
      <description>什么是css盒模型？ 根据css 2.1 中文版文档的描述:
CSS盒模型描述了一个为文档树中的元素生成的并根据视觉格式化模型进行布局的矩形框。
我们可以理解为css中每一个元素都是一个盒子，拥有四个区域，分别是：内容区(content)、内边距(padding)、边框(border)和外边距(margin)。 css盒模型分两种：border-box 和 content-box。
他们的区别在于content-box的宽度只包含content内容区，border-box的宽度包含到border，它包括content内容区、padding内边距、border边框。
返回CSS基础</description>
    </item>
    
    <item>
      <title>Html实践</title>
      <link>https://chow1027.xyz/2019/html%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 03 Nov 2019 13:42:58 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%AE%9E%E8%B7%B5/</guid>
      <description>选题 &amp;ndash;我最喜欢的动漫《某科学的超电磁炮》 以动漫《某科学的超电磁炮》为主题制作一个简易介绍网页，html裸奔。
收集内容 资料来源：
维基百科
萌娘百科
ToC &amp;ndash;Table of Content 为网页添加页内导航（锚点）
实现手段：为每一个标题添加id，通过a标签的href指向这个id。
&amp;lt;nav&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href =&amp;quot;#introduce&amp;quot;&amp;gt;作品介绍&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;h2 id =&amp;quot;introduce&amp;quot;&amp;gt;作品介绍&amp;lt;/h2&amp;gt;  添加外部资源 添加图片，注意：
 设置图片大小统一，不要让图片变形
width/height二选一设置相同的值。
 图片比例不对的要进行裁剪
 图片体积过大要进行压缩，一般不超过300kb
 添加图片预览
通过a标签超链接到原图，target设置为&amp;rdquo;_blank&amp;rdquo;。
  兼容手机  meta:vp
&amp;lt;!--meta:vp--&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&amp;quot;&amp;gt;  设置图片最大宽度为100%
img { max-width:100%; }   手机调试  通过chrome控制台
 wifi调试
  让手机和电脑处于同一wifi，手机直接用ip和端口访问页面。 注：
如果手机和电脑不在同一wifi，可以用映射端口，在chrome设置 &amp;gt; more tools &amp;gt; remote devices &amp;gt; Port forwarding 中设置。</description>
    </item>
    
    <item>
      <title>《HTML常用标签》</title>
      <link>https://chow1027.xyz/2019/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 01 Nov 2019 21:04:35 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      <description>a 标签 &amp;lt;!-- html --&amp;gt; &amp;lt;a href=&amp;quot;//google.com&amp;quot; target=&amp;quot;_blank&amp;quot; download rel=&amp;quot;noopener&amp;quot;&amp;gt; &amp;lt;/a&amp;gt;  作用 跳转到外部页面
跳转到内部锚点
跳转到电话/邮箱
属性 href
href 属性指定 a 标签要跳转到的新页面，他的取值可以是:
网址
 https://google.com http://google.com //google.com  可以是 https 也可以是 http，当采用无协议传输方式时，浏览器会自动采取 http 或 https。
路径
 a/b/c /a/b/c  当 href 指向某个路径时，a 标签实际访问的是 http 服务的根目录&amp;rdquo;/&amp;ldquo;（也就是这个网站相关文件的根目录）。
用&amp;rdquo;/&amp;ldquo;开头的即表示根目录，此时用的是绝对路径。
&amp;rdquo;./&amp;ldquo;的意思是在当前 html 所在的目录中找，这是一种相对路径。
伪协议
 javascript:代码; mailto:邮箱 tel:手机号  javascript:代码; 是 JS 的伪协议写法，用户点击 a 标签就执行该 JS 代码。
ID
&amp;rdquo;#xxx&amp;rdquo;
href 可以指向某个 ID，用户点击 a 标签页面就会跳转到该拥有该 ID 的标签所在的位置。</description>
    </item>
    
    <item>
      <title>Html入门笔记1</title>
      <link>https://chow1027.xyz/2019/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Thu, 31 Oct 2019 18:16:17 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      <description>什么是 HTML?它是谁发明的? 答：HTML 是超文本标记语言（Hypertext Markup Language）,在 1990 年由李爵士（Tim Berners-Lee）发明。
HTML 起手式 起手式唯一招式：&amp;rdquo;!+tab&amp;rdquo;
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt; &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt; &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  注：
 !要用英文输入法。 lang=&amp;quot;en&amp;quot;,language 为英文，建议改成&amp;rdquo;zh-CN&amp;rdquo;。 charset=&amp;quot;UTF-8&amp;quot;，支持各国字符的编码，不要改！ &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;防止页面缩放，适应手机屏幕。 &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;告诉浏览器采用最新的 ie 内核解析本页面。  HTML 章节标签 HTML 章节标签包括：
 h1 ~ h6,表示标题 1 ~ 标题 6 section,表示章节 article,表示文章 p,表示段落 header,表示页面的页眉（一般是页面的标题） main,表示页面的主要内容（页面主体部分） footer,表示页面的页脚（一般是版权声明、作者等） aside,表示旁支内容（与页面主体无关的部分,比如导航 条等） div,用于划分内容块  HTML 全局属性 全局属性是所有标签都有的属性。</description>
    </item>
    
    <item>
      <title>如何用hugo搭建个人博客</title>
      <link>https://chow1027.xyz/2019/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Wed, 30 Oct 2019 10:13:42 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>如何用 hugo 搭建个人博客 以下是简略步骤：
 hugo 下载&amp;amp;安装 建立新网站 添加主题 开始第一篇文章 启动 hugo 服务器 自定义主题 建立静态页面 将博客放到网上  从第一步到第五步已经完成个人博客的搭建，第六步到第八步锦上添花。
1、hugo 下载&amp;amp;安装（windows）  下载 hugo_xxxxx_Windows-64bit.zip； 解压，将 hugo.exe 放到软件目录中； 将 hugo.exe 的存放路径添加到系统高级配置的环境变量中； 运行hugo version检查 hugo.exe 是否安装成功。  hugo 下载地址
2、建立新网站  hugo new site quickstart
 注：quickstart 为你的博客仓库名。
3、添加主题 git init --创建一个git本地仓库 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke --添加默认主题ananke echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml --将默认主题添加到网站配置文件中  4、开始第一篇文章 hugo new posts/my-first-post.md 注意：&amp;rdquo;my-first-post&amp;rdquo;为你的第一篇博客的名字。 在编辑器中编写内容：</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>https://chow1027.xyz/2019/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Tue, 29 Oct 2019 22:39:18 +0800</pubDate>
      
      <guid>https://chow1027.xyz/2019/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>大家好 我的博客开通了，希望我也能写出好文章给大家看。</description>
    </item>
    
    <item>
      <title>Creating a New Theme</title>
      <link>https://chow1027.xyz/2014/creating-a-new-theme/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chow1027.xyz/2014/creating-a-new-theme/</guid>
      <description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description>
    </item>
    
    <item>
      <title>(Hu)go Template Primer</title>
      <link>https://chow1027.xyz/2014/goisforlovers/</link>
      <pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chow1027.xyz/2014/goisforlovers/</guid>
      <description>Hugo uses the excellent go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in go templates.
This document is a brief primer on using go templates.</description>
    </item>
    
    <item>
      <title>About Hugo</title>
      <link>https://chow1027.xyz/2014/about/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chow1027.xyz/2014/about/</guid>
      <description>Hugo is the world’s fastest framework for building websites. It is written in Go.
It makes use of a variety of open source projects including:
 https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Learn more and contribute on GitHub.</description>
    </item>
    
    <item>
      <title>Getting Started with Hugo</title>
      <link>https://chow1027.xyz/2014/hugoisforlovers/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chow1027.xyz/2014/hugoisforlovers/</guid>
      <description>Step 1. Install Hugo Goto hugo releases and download the appropriate version for your os and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at installing hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
 Clone the hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:</description>
    </item>
    
    <item>
      <title>Migrate to Hugo from Jekyll</title>
      <link>https://chow1027.xyz/2014/migrate-from-jekyll/</link>
      <pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://chow1027.xyz/2014/migrate-from-jekyll/</guid>
      <description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png  should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description>
    </item>
    
  </channel>
</rss>